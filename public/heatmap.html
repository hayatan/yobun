<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>ヒートマップ - Yobun</title>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --border-color: #30363d;
            --text-primary: #c9d1d9;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-yellow: #d29922;
            --accent-red: #f85149;
            --accent-orange: #f0883e;
            --cell-size: 100px;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.5;
            height: 100vh;
            overflow: hidden;
        }
        
        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 0;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        
        /* コンパクトヘッダー */
        .compact-header {
            display: flex;
            align-items: center;
            padding: 8px 4px;
            gap: 8px;
            background-color: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        
        .settings-btn {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
        }
        
        .current-info {
            flex: 1;
            font-size: 13px;
            color: var(--text-secondary);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .zoom-btn {
            min-width: 32px;
            padding: 6px 8px;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }
        
        #zoomLevel {
            min-width: 45px;
            text-align: center;
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        /* 設定オーバーレイ */
        .settings-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 100;
            display: none;
            justify-content: center;
            align-items: center;
            padding: 16px;
        }
        
        .settings-overlay.active {
            display: flex;
        }
        
        .settings-panel {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            max-width: 400px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .settings-header h2 {
            font-size: 18px;
            font-weight: 600;
            margin: 0;
        }
        
        .close-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .settings-content {
            padding: 16px;
        }
        
        .setting-group {
            margin-bottom: 16px;
        }
        
        .setting-group label {
            display: block;
            color: var(--text-secondary);
            font-size: 13px;
            margin-bottom: 6px;
        }
        
        .setting-group select,
        .setting-group input[type="date"] {
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            padding: 10px 12px;
            font-size: 14px;
            -webkit-appearance: none;
        }
        
        .settings-actions {
            margin-top: 20px;
        }
        
        .primary-btn {
            width: 100%;
            background-color: var(--accent-blue);
            border: none;
            border-radius: 6px;
            color: white;
            padding: 12px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
        }
        
        .primary-btn:hover {
            opacity: 0.9;
        }
        
        .settings-nav {
            display: flex;
            gap: 16px;
            margin-top: 20px;
            padding-top: 16px;
            border-top: 1px solid var(--border-color);
            justify-content: center;
        }
        
        .settings-nav a {
            color: var(--accent-blue);
            text-decoration: none;
            font-size: 13px;
        }
        
        button.btn-secondary {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
        }
        
        /* ヒートマップコンテナ */
        .heatmap-container {
            overflow: hidden;
            background-color: var(--bg-primary);
            border: none;
            border-radius: 0;
            padding: 4px;
            touch-action: none;
            flex: 1;
            cursor: grab;
        }
        
        .heatmap-container:active {
            cursor: grabbing;
        }
        
        /* PC向けはやや余裕を持たせる */
        @media (min-width: 768px) {
            .container {
                padding: 8px;
            }
            .heatmap-container {
                padding: 8px;
                border-radius: 8px;
            }
        }
        
        .heatmap-grid {
            display: grid;
            gap: 2px;
            width: fit-content;
        }
        
        /* セルスタイル */
        .cell {
            min-width: var(--cell-size);
            min-height: var(--cell-size);
            background-color: var(--bg-tertiary);
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            padding: 4px;
            font-size: 10px;
            overflow: hidden;
            position: relative;
        }
        
        /* マージされたセルは自動サイズ */
        .cell.merged {
            align-items: center;
            justify-content: center;
            font-size: 11px;
        }
        
        .cell.machine {
            border-left: 3px solid var(--border-color);
            cursor: pointer;
        }
        
        .cell.machine:hover {
            outline: 2px solid var(--accent-blue);
        }
        
        .cell.empty {
            background-color: transparent;
        }
        
        .cell.structure {
            background-color: #3d4450;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            color: #a0aab8;
            border: 1px dashed #556070;
        }
        
        .cell.structure.escalator { 
            background-color: #2a4a5a; 
            border-color: #4a7a8a;
        }
        .cell.structure.stairs { 
            background-color: #2a4a5a; 
            border-color: #4a7a8a;
        }
        .cell.structure.counter { 
            background-color: #5a4a3a; 
            border-color: #8a7a5a;
        }
        .cell.structure.locker { 
            background-color: #4a3a5a; 
            border-color: #7a5a8a;
        }
        .cell.structure.vending { 
            background-color: #3a5a4a; 
            border-color: #5a8a7a;
        }
        .cell.structure.pillar { 
            background-color: #5a5a5a; 
            border-color: #8a8a8a;
        }
        .cell.structure.shelf { 
            background-color: #4a4535; 
            border-color: #7a7555;
        }
        .cell.structure.restroom { 
            background-color: #3a4a5a; 
            border-color: #5a7a9a;
        }
        .cell.structure.entrance { 
            background-color: #3a5a3a; 
            border-color: #5a8a5a;
        }
        .cell.structure.other { 
            background-color: #4a4a4a; 
            border-color: #7a7a7a;
        }
        
        .cell.label {
            background-color: #2a2f38;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            color: #8090a0;
            border: 1px solid #404550;
        }
        
        /* マージされたセル */
        .cell.merged {
            font-size: 12px;
            text-align: center;
            word-break: break-all;
            padding: 8px;
        }
        
        /* 台セルの内容 */
        .cell-number {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 11px;
        }
        
        .cell-machine {
            color: var(--text-secondary);
            font-size: 9px;
            line-height: 1.2;
            height: 22px;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }
        
        .cell-metrics {
            display: flex;
            flex-direction: column;
            gap: 1px;
            flex: 1;
            justify-content: flex-end;
        }
        
        .cell-metric-row {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .cell-metric-period {
            font-size: 8px;
            color: var(--text-secondary);
            width: 20px;
        }
        
        .cell-metric-value {
            font-size: 12px;
            font-weight: 600;
        }
        
        .cell-metric-winrate {
            font-size: 10px;
        }
        
        /* 比較モード */
        .cell.compare-mode .cell-metrics {
            gap: 0;
        }
        
        .cell.compare-mode .metric-divider {
            border-top: 1px solid var(--border-color);
            margin: 2px 0;
        }
        
        /* ローディング */
        .loading {
            text-align: center;
            padding: 48px;
            color: var(--text-secondary);
        }
        
        /* モーダル */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .modal-overlay.active {
            display: flex;
        }
        
        .modal {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            max-width: 400px;
            width: 90%;
        }
        
        .modal h3 {
            margin-bottom: 12px;
            font-size: 16px;
        }
        
        .modal-content {
            font-size: 13px;
            color: var(--text-secondary);
        }
        
        .modal-content .detail-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .modal-content .detail-label {
            color: var(--text-secondary);
        }
        
        .modal-content .detail-value {
            color: var(--text-primary);
            font-weight: 500;
        }
        
        .modal-close {
            margin-top: 16px;
            width: 100%;
        }
        
        /* モバイル向けセルサイズ調整 */
        @media (max-width: 768px) {
            .compact-header {
                padding: 6px 4px;
            }
            
            .zoom-btn {
                min-width: 28px;
                padding: 4px 6px;
                font-size: 12px;
            }
            
            #zoomLevel {
                min-width: 40px;
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- コンパクトヘッダー（常時表示） -->
        <div class="compact-header">
            <button class="settings-btn" id="settingsBtn" title="設定">☰</button>
            <span class="current-info" id="currentInfo">データを読み込んでください</span>
            <div class="zoom-controls">
                <button id="zoomOutBtn" class="zoom-btn">−</button>
                <span id="zoomLevel">100%</span>
                <button id="zoomInBtn" class="zoom-btn">+</button>
                <button id="zoomResetBtn" class="zoom-btn">⟲</button>
            </div>
        </div>
        
        <div class="heatmap-container" id="heatmapContainer">
            <div class="loading">設定ボタンから店舗を選択してください</div>
        </div>
    </div>
    
    <!-- 設定オーバーレイ -->
    <div class="settings-overlay active" id="settingsOverlay">
        <div class="settings-panel">
            <div class="settings-header">
                <h2>設定</h2>
                <button class="close-btn" id="settingsCloseBtn">×</button>
            </div>
            <div class="settings-content">
                <div class="setting-group">
                    <label for="holeSelect">店舗</label>
                    <select id="holeSelect">
                        <option value="">選択してください</option>
                    </select>
                </div>
                <div class="setting-group">
                    <label for="dateSelect">日付</label>
                    <input type="date" id="dateSelect">
                </div>
                <div class="setting-group">
                    <label for="period1Select">期間</label>
                    <select id="period1Select">
                        <option value="d5">5日間</option>
                        <option value="d3">3日間</option>
                        <option value="d7">7日間</option>
                        <option value="d14">14日間</option>
                        <option value="d28">28日間</option>
                        <option value="mtd">当月</option>
                        <option value="all">全期間</option>
                    </select>
                </div>
                <div class="setting-group">
                    <label>
                        <input type="checkbox" id="compareModeCheck"> 比較モード
                    </label>
                </div>
                <div class="setting-group" id="period2Group" style="display: none;">
                    <label for="period2Select">期間2</label>
                    <select id="period2Select">
                        <option value="d28">28日間</option>
                        <option value="d14">14日間</option>
                        <option value="d7">7日間</option>
                        <option value="mtd">当月</option>
                        <option value="all">全期間</option>
                    </select>
                </div>
                <div class="settings-actions">
                    <button id="loadBtn" class="primary-btn">表示</button>
                </div>
                <nav class="settings-nav">
                    <a href="/dashboard">ダッシュボード</a>
                    <a href="/heatmap-editor">レイアウト編集</a>
                </nav>
            </div>
        </div>
    </div>
    
    <!-- 詳細モーダル -->
    <div id="detailModal" class="modal-overlay">
        <div class="modal">
            <h3 id="modalTitle">台詳細</h3>
            <div class="modal-content" id="modalContent"></div>
            <button class="modal-close btn-secondary" id="modalCloseBtn">閉じる</button>
        </div>
    </div>
    
    <script>
        // ============================================================================
        // 状態管理
        // ============================================================================
        let layoutData = null;
        let machineData = null;
        let currentHole = '';
        let currentDate = '';
        
        // ズーム・パン関連
        let zoomLevel = 1;
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;
        let lastPanX = 0;
        let lastPanY = 0;
        let initialPinchDistance = 0;
        let initialZoom = 1;
        let pinchGridX = 0;  // ピンチ中心のグリッドX座標
        let pinchGridY = 0;  // ピンチ中心のグリッドY座標
        
        // ============================================================================
        // 色計算（出率・勝率）
        // ============================================================================
        
        // 出率の色計算
        // 100%以下=白、105%=橙、110%以上=赤
        function getPayoutColor(rate) {
            if (rate === null || rate === undefined) return 'var(--text-secondary)';
            const pct = rate * 100;
            if (pct <= 100) {
                return '#c9d1d9'; // 白
            } else if (pct <= 105) {
                // 100-105: 白→橙のグラデーション
                const t = (pct - 100) / 5;
                return interpolateColor('#c9d1d9', '#f0883e', t);
            } else if (pct <= 110) {
                // 105-110: 橙→赤のグラデーション
                const t = (pct - 105) / 5;
                return interpolateColor('#f0883e', '#f85149', t);
            } else {
                return '#f85149'; // 赤
            }
        }
        
        // 勝率の色計算
        // 50%以下=白、80%=橙、99%=赤橙、0%=青、100%=赤
        function getWinRateColor(rate) {
            if (rate === null || rate === undefined) return 'var(--text-secondary)';
            const pct = rate * 100;
            if (pct === 0) {
                return '#58a6ff'; // 青（全敗）
            } else if (pct === 100) {
                return '#f85149'; // 赤（全勝）
            } else if (pct <= 50) {
                return '#c9d1d9'; // 白
            } else if (pct <= 80) {
                // 50-80: 白→橙のグラデーション
                const t = (pct - 50) / 30;
                return interpolateColor('#c9d1d9', '#f0883e', t);
            } else {
                // 80-99: 橙→赤橙のグラデーション
                const t = (pct - 80) / 19;
                return interpolateColor('#f0883e', '#f85149', t);
            }
        }
        
        // 色の補間
        function interpolateColor(color1, color2, t) {
            const c1 = hexToRgb(color1);
            const c2 = hexToRgb(color2);
            const r = Math.round(c1.r + (c2.r - c1.r) * t);
            const g = Math.round(c1.g + (c2.g - c1.g) * t);
            const b = Math.round(c1.b + (c2.b - c1.b) * t);
            return `rgb(${r}, ${g}, ${b})`;
        }
        
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 200, g: 200, b: 200 };
        }
        
        // ============================================================================
        // UI初期化
        // ============================================================================
        
        async function init() {
            // 店舗一覧を取得
            try {
                const response = await fetch('/api/heatmap/layouts');
                const data = await response.json();
                
                const select = document.getElementById('holeSelect');
                data.layouts.forEach(layout => {
                    const option = document.createElement('option');
                    option.value = layout.hole;
                    option.textContent = layout.hole;
                    select.appendChild(option);
                });
                
                // デフォルト選択
                if (data.layouts.length > 0) {
                    select.value = data.layouts[0].hole;
                }
            } catch (error) {
                console.error('レイアウト一覧取得エラー:', error);
            }
            
            // 日付をデフォルト設定（昨日）
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            document.getElementById('dateSelect').value = yesterday.toISOString().split('T')[0];
            
            // イベントリスナー
            document.getElementById('loadBtn').addEventListener('click', loadHeatmap);
            document.getElementById('compareModeCheck').addEventListener('change', toggleCompareMode);
            document.getElementById('modalCloseBtn').addEventListener('click', closeModal);
            document.getElementById('detailModal').addEventListener('click', (e) => {
                if (e.target === document.getElementById('detailModal')) closeModal();
            });
            
            // 設定オーバーレイ
            document.getElementById('settingsBtn').addEventListener('click', openSettings);
            document.getElementById('settingsCloseBtn').addEventListener('click', closeSettings);
            document.getElementById('settingsOverlay').addEventListener('click', (e) => {
                if (e.target === document.getElementById('settingsOverlay')) closeSettings();
            });
            
            // ズーム・パン機能
            setupZoomPan();
            
            // ズームコントロール
            document.getElementById('zoomInBtn').addEventListener('click', zoomIn);
            document.getElementById('zoomOutBtn').addEventListener('click', zoomOut);
            document.getElementById('zoomResetBtn').addEventListener('click', resetZoom);
        }
        
        function openSettings() {
            document.getElementById('settingsOverlay').classList.add('active');
        }
        
        function closeSettings() {
            document.getElementById('settingsOverlay').classList.remove('active');
        }
        
        function updateCurrentInfo() {
            const hole = document.getElementById('holeSelect').value;
            const date = document.getElementById('dateSelect').value;
            const period = document.getElementById('period1Select');
            const periodText = period.options[period.selectedIndex]?.text || '';
            
            if (hole && date) {
                document.getElementById('currentInfo').textContent = `${hole} | ${date} | ${periodText}`;
            } else {
                document.getElementById('currentInfo').textContent = 'データを読み込んでください';
            }
        }
        
        // ============================================================================
        // ズーム・パン機能
        // ============================================================================
        
        function setupZoomPan() {
            const container = document.getElementById('heatmapContainer');
            
            // ホイールでズーム（スクロール無効化）
            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -0.1 : 0.1;
                const newZoom = Math.max(0.2, Math.min(3, zoomLevel + delta));
                
                // マウス位置を中心にズーム
                const rect = container.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                const gridX = (mouseX - panX) / zoomLevel;
                const gridY = (mouseY - panY) / zoomLevel;
                
                zoomLevel = newZoom;
                
                panX = mouseX - gridX * zoomLevel;
                panY = mouseY - gridY * zoomLevel;
                
                applyZoomPan();
            }, { passive: false });
            
            // 左クリック+ドラッグでパン（表示モードは直接パン可能）
            container.addEventListener('mousedown', (e) => {
                if (e.button === 0 || e.button === 1) {
                    e.preventDefault();
                    isPanning = true;
                    panStartX = e.clientX;
                    panStartY = e.clientY;
                    lastPanX = panX;
                    lastPanY = panY;
                    container.style.cursor = 'grabbing';
                }
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isPanning) {
                    panX = lastPanX + (e.clientX - panStartX);
                    panY = lastPanY + (e.clientY - panStartY);
                    applyZoomPan();
                }
            });
            
            document.addEventListener('mouseup', () => {
                if (isPanning) {
                    isPanning = false;
                    document.getElementById('heatmapContainer').style.cursor = '';
                }
            });
            
            // タッチ操作
            let isTouchPanning = false;
            let isPinching = false;
            let touchStartTime = 0;
            let touchStartTarget = null;
            let touchMoved = false;
            const TAP_THRESHOLD = 10; // タップ判定の移動許容範囲（px）
            const TAP_DURATION = 300; // タップ判定の最大時間（ms）
            
            container.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    // 1本指: パン準備（タップかもしれない）
                    e.preventDefault();
                    isTouchPanning = true;
                    isPinching = false;
                    touchMoved = false;
                    touchStartTime = Date.now();
                    touchStartTarget = e.target;
                    panStartX = e.touches[0].clientX;
                    panStartY = e.touches[0].clientY;
                    lastPanX = panX;
                    lastPanY = panY;
                } else if (e.touches.length === 2) {
                    // 2本指: ピンチズーム
                    e.preventDefault();
                    isTouchPanning = false;
                    isPinching = true;
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    initialPinchDistance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );
                    initialZoom = zoomLevel;
                    
                    // ピンチ中心のコンテナ内座標
                    const rect = container.getBoundingClientRect();
                    const centerX = (touch1.clientX + touch2.clientX) / 2 - rect.left;
                    const centerY = (touch1.clientY + touch2.clientY) / 2 - rect.top;
                    
                    // ピンチ中心のグリッド座標を記録（ズーム基準点）
                    pinchGridX = (centerX - panX) / zoomLevel;
                    pinchGridY = (centerY - panY) / zoomLevel;
                }
            }, { passive: false });
            
            container.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1 && isTouchPanning) {
                    // 1本指パン
                    e.preventDefault();
                    const deltaX = e.touches[0].clientX - panStartX;
                    const deltaY = e.touches[0].clientY - panStartY;
                    
                    // 移動距離が閾値を超えたらドラッグとみなす
                    if (Math.abs(deltaX) > TAP_THRESHOLD || Math.abs(deltaY) > TAP_THRESHOLD) {
                        touchMoved = true;
                    }
                    
                    panX = lastPanX + deltaX;
                    panY = lastPanY + deltaY;
                    applyZoomPan();
                } else if (e.touches.length === 2 && isPinching) {
                    // 2本指ピンチズーム
                    e.preventDefault();
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    
                    // 現在のピンチ距離からズーム倍率を計算
                    const currentDistance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );
                    const scale = currentDistance / initialPinchDistance;
                    zoomLevel = Math.max(0.2, Math.min(3, initialZoom * scale));
                    
                    // 現在のピンチ中心（コンテナ内座標）
                    const rect = container.getBoundingClientRect();
                    const centerX = (touch1.clientX + touch2.clientX) / 2 - rect.left;
                    const centerY = (touch1.clientY + touch2.clientY) / 2 - rect.top;
                    
                    // ピンチ中心が画面上の同じ位置に留まるようにパン調整
                    panX = centerX - pinchGridX * zoomLevel;
                    panY = centerY - pinchGridY * zoomLevel;
                    
                    applyZoomPan();
                }
            }, { passive: false });
            
            container.addEventListener('touchend', (e) => {
                // タップ判定: 移動が少なく、時間が短い場合
                if (isTouchPanning && !touchMoved && (Date.now() - touchStartTime) < TAP_DURATION) {
                    // タップしたセルを特定してクリックイベントを発火
                    const cell = touchStartTarget?.closest('.cell');
                    if (cell) {
                        cell.click();
                    }
                }
                
                isTouchPanning = false;
                isPinching = false;
                touchMoved = false;
            });
        }
        
        function applyZoomPan() {
            const container = document.getElementById('heatmapContainer');
            const grid = document.querySelector('.heatmap-grid');
            if (!grid) return;
            
            // パン範囲を制限（グリッドの一部は常に見えるように）
            const containerRect = container.getBoundingClientRect();
            const gridWidth = grid.offsetWidth * zoomLevel;
            const gridHeight = grid.offsetHeight * zoomLevel;
            const margin = 50; // 最低限見える範囲（px）
            
            const minX = containerRect.width - gridWidth - margin;
            const maxX = margin;
            const minY = containerRect.height - gridHeight - margin;
            const maxY = margin;
            
            panX = Math.max(minX, Math.min(maxX, panX));
            panY = Math.max(minY, Math.min(maxY, panY));
            
            grid.style.transform = `translate(${panX}px, ${panY}px) scale(${zoomLevel})`;
            grid.style.transformOrigin = '0 0';
            updateZoomDisplay();
        }
        
        function updateZoomDisplay() {
            const zoomDisplay = document.getElementById('zoomLevel');
            if (zoomDisplay) {
                zoomDisplay.textContent = `${Math.round(zoomLevel * 100)}%`;
            }
        }
        
        function zoomIn() {
            zoomLevel = Math.min(3, zoomLevel + 0.2);
            applyZoomPan();
        }
        
        function zoomOut() {
            zoomLevel = Math.max(0.2, zoomLevel - 0.2);
            applyZoomPan();
        }
        
        function resetZoom() {
            zoomLevel = 1;
            panX = 0;
            panY = 0;
            applyZoomPan();
        }
        
        function toggleCompareMode() {
            const isCompare = document.getElementById('compareModeCheck').checked;
            document.getElementById('period2Group').style.display = isCompare ? 'flex' : 'none';
        }
        
        // ============================================================================
        // データ読み込み
        // ============================================================================
        
        async function loadHeatmap() {
            const hole = document.getElementById('holeSelect').value;
            const targetDate = document.getElementById('dateSelect').value;
            
            if (!hole) {
                alert('店舗を選択してください');
                return;
            }
            
            currentHole = hole;
            currentDate = targetDate;
            
            const container = document.getElementById('heatmapContainer');
            container.innerHTML = '<div class="loading">読み込み中...</div>';
            
            try {
                // レイアウトとデータを並列で取得
                const [layoutRes, dataRes] = await Promise.all([
                    fetch(`/api/heatmap/layouts/${encodeURIComponent(hole)}`),
                    fetch(`/api/heatmap/data?hole=${encodeURIComponent(hole)}&targetDate=${targetDate}`)
                ]);
                
                if (!layoutRes.ok) {
                    throw new Error('レイアウトデータの取得に失敗しました');
                }
                if (!dataRes.ok) {
                    throw new Error('機種データの取得に失敗しました');
                }
                
                layoutData = await layoutRes.json();
                machineData = await dataRes.json();
                
                // 現在の情報を更新
                updateCurrentInfo();
                
                // 設定オーバーレイを閉じる
                closeSettings();
                
                // ヒートマップ描画
                renderHeatmap();
                
            } catch (error) {
                console.error('ヒートマップ読み込みエラー:', error);
                container.innerHTML = `<div class="loading" style="color: var(--accent-red);">エラー: ${error.message}</div>`;
            }
        }
        
        function updateInfoBar() {
            const infoBar = document.getElementById('infoBar');
            const period1 = document.getElementById('period1Select').value;
            const isCompare = document.getElementById('compareModeCheck').checked;
            const period2 = document.getElementById('period2Select').value;
            
            const periodLabel = {
                d1: '1日', d2: '2日', d3: '3日', d4: '4日', d5: '5日',
                d6: '6日', d7: '7日', d14: '14日', d28: '28日', mtd: '当月', all: '全期間'
            };
            
            let html = `
                <div class="info-item">店舗: <strong>${currentHole}</strong></div>
                <div class="info-item">日付: <strong>${machineData.targetDate}</strong></div>
                <div class="info-item">台数: <strong>${machineData.machineCount}</strong></div>
                <div class="info-item">期間: <strong>${periodLabel[period1] || period1}</strong></div>
            `;
            
            if (isCompare) {
                html += `<div class="info-item">比較: <strong>${periodLabel[period2] || period2}</strong></div>`;
            }
            
            infoBar.innerHTML = html;
        }
        
        // ============================================================================
        // ヒートマップ描画
        // ============================================================================
        
        function renderHeatmap() {
            const container = document.getElementById('heatmapContainer');
            const period1 = document.getElementById('period1Select').value;
            const isCompare = document.getElementById('compareModeCheck').checked;
            const period2 = document.getElementById('period2Select').value;
            
            const { grid, cells, walls } = layoutData;
            
            // グリッドを作成
            const gridElement = document.createElement('div');
            gridElement.className = 'heatmap-grid';
            gridElement.style.gridTemplateColumns = `repeat(${grid.cols}, var(--cell-size))`;
            gridElement.style.gridTemplateRows = `repeat(${grid.rows}, var(--cell-size))`;
            
            // セルをマップ化
            const cellMap = new Map();
            const mergedCells = new Set(); // マージされた子セルの位置
            
            cells.forEach(cell => {
                cellMap.set(`${cell.row}-${cell.col}`, cell);
                
                // マージされたセルをマーク
                if (cell.mergeRows > 1 || cell.mergeCols > 1) {
                    const mr = cell.mergeRows || 1;
                    const mc = cell.mergeCols || 1;
                    for (let r = 0; r < mr; r++) {
                        for (let c = 0; c < mc; c++) {
                            if (r !== 0 || c !== 0) {
                                mergedCells.add(`${cell.row + r}-${cell.col + c}`);
                            }
                        }
                    }
                }
            });
            
            // グリッドを埋める
            for (let row = 0; row < grid.rows; row++) {
                for (let col = 0; col < grid.cols; col++) {
                    const key = `${row}-${col}`;
                    const cellData = cellMap.get(key);
                    
                    // マージされた子セルはスキップ（親セルがspanで覆う）
                    if (mergedCells.has(key)) {
                        continue;
                    }
                    
                    const cellElement = document.createElement('div');
                    cellElement.className = 'cell';
                    
                    if (cellData) {
                        renderCell(cellElement, cellData, period1, isCompare ? period2 : null);
                        
                        // マージされたセル（親）は大きく表示
                        if (cellData.mergeRows > 1 || cellData.mergeCols > 1) {
                            const mr = cellData.mergeRows || 1;
                            const mc = cellData.mergeCols || 1;
                            cellElement.style.gridRow = `${row + 1} / span ${mr}`;
                            cellElement.style.gridColumn = `${col + 1} / span ${mc}`;
                        } else {
                            cellElement.style.gridRow = String(row + 1);
                            cellElement.style.gridColumn = String(col + 1);
                        }
                    } else {
                        cellElement.classList.add('empty');
                        cellElement.style.gridRow = String(row + 1);
                        cellElement.style.gridColumn = String(col + 1);
                    }
                    
                    gridElement.appendChild(cellElement);
                }
            }
            
            container.innerHTML = '';
            container.appendChild(gridElement);
        }
        
        function renderCell(element, cellData, period1, period2) {
            const { type, subtype, number, text, label, mergeRows, mergeCols } = cellData;
            
            // マージされたセル
            if (mergeRows > 1 || mergeCols > 1) {
                element.classList.add('merged');
            }
            
            if (type === 'machine') {
                element.classList.add('machine');
                const data = machineData.machines[number];
                
                if (data) {
                    const payout1 = data[`${period1}_payout_rate`];
                    const winRate1 = data[`${period1}_win_rate`];
                    
                    // 左ボーダー色
                    element.style.borderLeftColor = getPayoutColor(payout1);
                    
                    // 台番号
                    const numberEl = document.createElement('div');
                    numberEl.className = 'cell-number';
                    numberEl.textContent = number;
                    element.appendChild(numberEl);
                    
                    // 機種名
                    const machineEl = document.createElement('div');
                    machineEl.className = 'cell-machine';
                    machineEl.textContent = data.machine || '';
                    element.appendChild(machineEl);
                    
                    // メトリクス
                    const metricsEl = document.createElement('div');
                    metricsEl.className = 'cell-metrics';
                    
                    if (period2) {
                        element.classList.add('compare-mode');
                        // 期間1
                        metricsEl.appendChild(createMetricRow(period1, payout1, winRate1));
                        // 区切り線
                        const divider = document.createElement('div');
                        divider.className = 'metric-divider';
                        metricsEl.appendChild(divider);
                        // 期間2
                        const payout2 = data[`${period2}_payout_rate`];
                        const winRate2 = data[`${period2}_win_rate`];
                        metricsEl.appendChild(createMetricRow(period2, payout2, winRate2));
                    } else {
                        metricsEl.appendChild(createMetricRow(period1, payout1, winRate1, true));
                    }
                    
                    element.appendChild(metricsEl);
                    
                    // クリックイベント
                    element.addEventListener('click', () => showDetail(number, data));
                } else {
                    // データなし
                    element.innerHTML = `<div class="cell-number">${number}</div><div style="color: var(--text-secondary); font-size: 9px;">データなし</div>`;
                }
                
            } else if (type === 'structure') {
                element.classList.add('structure', subtype || '');
                const icons = {
                    escalator: '↑↓',
                    stairs: '階段',
                    counter: 'カウンター',
                    locker: 'ロッカー',
                    vending: '自販機',
                    pillar: '■',
                    other: label || ''
                };
                element.textContent = label || icons[subtype] || subtype || '';
                
            } else if (type === 'label') {
                element.classList.add('label');
                element.textContent = text || '';
            }
        }
        
        function createMetricRow(period, payout, winRate, showFull = false) {
            const row = document.createElement('div');
            row.className = 'cell-metric-row';
            
            // 期間ラベル
            const periodEl = document.createElement('span');
            periodEl.className = 'cell-metric-period';
            periodEl.textContent = period;
            row.appendChild(periodEl);
            
            // 出率
            const payoutEl = document.createElement('span');
            payoutEl.className = 'cell-metric-value';
            payoutEl.style.color = getPayoutColor(payout);
            payoutEl.textContent = payout !== null && payout !== undefined 
                ? `${Math.round(payout * 100)}%` : '-';
            row.appendChild(payoutEl);
            
            // 勝率
            const winEl = document.createElement('span');
            winEl.className = 'cell-metric-winrate';
            winEl.style.color = getWinRateColor(winRate);
            winEl.textContent = winRate !== null && winRate !== undefined 
                ? `${Math.round(winRate * 100)}%` : '-';
            row.appendChild(winEl);
            
            return row;
        }
        
        // ============================================================================
        // 詳細モーダル
        // ============================================================================
        
        function showDetail(number, data) {
            const modal = document.getElementById('detailModal');
            const title = document.getElementById('modalTitle');
            const content = document.getElementById('modalContent');
            
            title.textContent = `台番: ${number}`;
            
            const periods = ['d1', 'd3', 'd5', 'd7', 'd14', 'd28', 'mtd', 'all'];
            const periodLabels = {
                d1: '1日', d3: '3日', d5: '5日', d7: '7日',
                d14: '14日', d28: '28日', mtd: '当月', all: '全期間'
            };
            
            let html = `
                <div class="detail-row">
                    <span class="detail-label">機種名</span>
                    <span class="detail-value">${data.machine || '-'}</span>
                </div>
            `;
            
            periods.forEach(p => {
                const payout = data[`${p}_payout_rate`];
                const winRate = data[`${p}_win_rate`];
                const diff = data[`${p}_diff`];
                
                if (payout !== null && payout !== undefined) {
                    html += `
                        <div class="detail-row">
                            <span class="detail-label">${periodLabels[p]}</span>
                            <span class="detail-value">
                                <span style="color: ${getPayoutColor(payout)}">${Math.round(payout * 100)}%</span>
                                ${winRate !== null ? `/ <span style="color: ${getWinRateColor(winRate)}">${Math.round(winRate * 100)}%</span>` : ''}
                                ${diff !== null ? `/ ${diff > 0 ? '+' : ''}${diff}枚` : ''}
                            </span>
                        </div>
                    `;
                }
            });
            
            content.innerHTML = html;
            modal.classList.add('active');
        }
        
        function closeModal() {
            document.getElementById('detailModal').classList.remove('active');
        }
        
        // ============================================================================
        // 初期化
        // ============================================================================
        init();
    </script>
</body>
</html>
