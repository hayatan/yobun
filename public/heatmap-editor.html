<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆç·¨é›† - Yobun</title>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --border-color: #30363d;
            --text-primary: #c9d1d9;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-yellow: #d29922;
            --accent-red: #f85149;
            --accent-orange: #f0883e;
            --cell-size: 40px;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.5;
            height: 100vh;
            overflow: hidden;
        }
        
        /* ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        /* ãƒ˜ãƒƒãƒ€ãƒ¼ */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 16px;
            background-color: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        
        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        h1 {
            font-size: 16px;
            font-weight: 600;
        }
        
        .header-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        select {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            padding: 6px 10px;
            font-size: 13px;
        }
        
        nav {
            display: flex;
            gap: 12px;
        }
        
        nav a {
            color: var(--accent-blue);
            text-decoration: none;
            font-size: 13px;
        }
        
        /* ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ */
        .toolbar {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background-color: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        
        .tool-group {
            display: flex;
            gap: 4px;
            padding-right: 12px;
            border-right: 1px solid var(--border-color);
        }
        
        .tool-group:last-child {
            border-right: none;
        }
        
        .tool-btn {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .tool-btn:hover {
            background-color: #2d333b;
        }
        
        .tool-btn.active {
            background-color: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }
        
        .tool-btn.save-btn {
            background-color: var(--accent-green);
            border-color: var(--accent-green);
            color: white;
        }
        
        .tool-btn.save-btn:hover {
            opacity: 0.9;
        }
        
        /* ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ */
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        /* ã‚µã‚¤ãƒ‰ãƒ‘ãƒãƒ« */
        .side-panel {
            width: 180px;
            background-color: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }
        
        .panel-section {
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .panel-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 8px;
        }
        
        .structure-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .structure-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }
        
        .structure-item:hover {
            border-color: var(--accent-blue);
        }
        
        .structure-item.selected {
            border-color: var(--accent-blue);
            background-color: rgba(88, 166, 255, 0.1);
        }
        
        .structure-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            font-size: 10px;
        }
        
        .structure-icon.escalator { background-color: #2a4a5a; }
        .structure-icon.stairs { background-color: #2a4a5a; }
        .structure-icon.counter { background-color: #5a4a3a; }
        .structure-icon.locker { background-color: #4a3a5a; }
        .structure-icon.vending { background-color: #3a5a4a; }
        .structure-icon.shelf { background-color: #4a4535; }
        .structure-icon.pillar { background-color: #5a5a5a; }
        .structure-icon.label { background-color: #2a2f38; }
        
        /* ã‚°ãƒªãƒƒãƒ‰ã‚³ãƒ³ãƒ†ãƒŠ */
        .grid-container {
            flex: 1;
            overflow: auto;
            padding: 16px;
            background-color: var(--bg-primary);
        }
        
        .editor-grid {
            display: grid;
            gap: 1px;
            background-color: var(--border-color);
            width: fit-content;
            border: 1px solid var(--border-color);
        }
        
        /* ã‚»ãƒ« */
        .editor-cell {
            min-width: var(--cell-size);
            min-height: var(--cell-size);
            background-color: var(--bg-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            cursor: pointer;
            position: relative;
            user-select: none;
        }
        
        .editor-cell:hover {
            outline: 2px solid var(--accent-blue);
            outline-offset: -2px;
            z-index: 1;
        }
        
        .editor-cell.selected {
            outline: 2px solid var(--accent-green);
            outline-offset: -2px;
            z-index: 2;
        }
        
        .editor-cell.machine {
            background-color: var(--bg-tertiary);
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .editor-cell.structure {
            background-color: #3d4450;
            color: #a0aab8;
            border: 1px dashed #556070;
        }
        
        .editor-cell.structure.escalator { background-color: #2a4a5a; }
        .editor-cell.structure.stairs { background-color: #2a4a5a; }
        .editor-cell.structure.counter { background-color: #5a4a3a; }
        .editor-cell.structure.locker { background-color: #4a3a5a; }
        .editor-cell.structure.vending { background-color: #3a5a4a; }
        .editor-cell.structure.shelf { background-color: #4a4535; }
        .editor-cell.structure.pillar { background-color: #5a5a5a; }
        
        .editor-cell.label {
            background-color: #2a2f38;
            color: #8090a0;
        }
        
        /* å£ï¼ˆãƒœãƒ¼ãƒ€ãƒ¼ï¼‰ */
        .editor-cell.wall-top { border-top: 3px solid #888 !important; }
        .editor-cell.wall-right { border-right: 3px solid #888 !important; }
        .editor-cell.wall-bottom { border-bottom: 3px solid #888 !important; }
        .editor-cell.wall-left { border-left: 3px solid #888 !important; }
        
        /* ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ‘ãƒãƒ« */
        .property-panel {
            width: 220px;
            background-color: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }
        
        .property-content {
            padding: 12px;
        }
        
        .property-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 12px;
        }
        
        .property-label {
            font-size: 11px;
            color: var(--text-secondary);
        }
        
        .property-value {
            font-size: 13px;
            color: var(--text-primary);
        }
        
        .property-input {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            padding: 6px 8px;
            font-size: 13px;
            width: 100%;
        }
        
        .property-btn {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            width: 100%;
            margin-top: 4px;
        }
        
        .property-btn:hover {
            background-color: #2d333b;
        }
        
        .property-btn.danger {
            background-color: rgba(248, 81, 73, 0.2);
            border-color: var(--accent-red);
            color: var(--accent-red);
        }
        
        /* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼ */
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 16px;
            background-color: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            font-size: 11px;
            color: var(--text-secondary);
            flex-shrink: 0;
        }
        
        .status-info {
            display: flex;
            gap: 16px;
        }
        
        /* ãƒ¢ãƒ¼ãƒ€ãƒ« */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .modal-overlay.active {
            display: flex;
        }
        
        .modal {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            min-width: 300px;
        }
        
        .modal h3 {
            margin-bottom: 16px;
            font-size: 16px;
        }
        
        .modal-buttons {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            margin-top: 16px;
        }
        
        .modal-btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            border: 1px solid var(--border-color);
        }
        
        .modal-btn.primary {
            background-color: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }
        
        .modal-btn.secondary {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        /* ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .editor-cell.dragging {
            opacity: 0.5;
        }
        
        .editor-cell.drag-over {
            background-color: rgba(88, 166, 255, 0.3) !important;
        }
        
        /* ãƒãƒ¼ã‚¸ã•ã‚ŒãŸã‚»ãƒ« */
        .editor-cell.merged-parent {
            font-size: 11px;
            padding: 8px;
            text-align: center;
            word-break: break-all;
        }
        
        .editor-cell.merged-parent.structure {
            border: 2px dashed #556070;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- ãƒ˜ãƒƒãƒ€ãƒ¼ -->
        <header>
            <div class="header-left">
                <h1>ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆç·¨é›†</h1>
                <div class="header-controls">
                    <select id="holeSelect">
                        <option value="">åº—èˆ—ã‚’é¸æŠ</option>
                    </select>
                    <button class="tool-btn" id="loadBtn">èª­ã¿è¾¼ã¿</button>
                </div>
            </div>
            <nav>
                <a href="/heatmap">ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—è¡¨ç¤º</a>
                <a href="/dashboard">ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰</a>
            </nav>
        </header>
        
        <!-- ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ -->
        <div class="toolbar">
            <div class="tool-group">
                <button class="tool-btn active" data-tool="select" title="é¸æŠ (V)">
                    <span>â†–</span> é¸æŠ
                </button>
                <button class="tool-btn" data-tool="machine" title="å°è¿½åŠ  (M)">
                    <span>ğŸ°</span> å°è¿½åŠ 
                </button>
                <button class="tool-btn" data-tool="structure" title="æ§‹é€ ç‰© (S)">
                    <span>ğŸ—</span> æ§‹é€ ç‰©
                </button>
                <button class="tool-btn" data-tool="wall" title="å£ (W)">
                    <span>â–¬</span> å£
                </button>
                <button class="tool-btn" data-tool="eraser" title="æ¶ˆã—ã‚´ãƒ  (E)">
                    <span>ğŸ§¹</span> å‰Šé™¤
                </button>
            </div>
            <div class="tool-group">
                <button class="tool-btn" id="undoBtn" title="å…ƒã«æˆ»ã™ (Ctrl+Z)">â†© æˆ»ã™</button>
                <button class="tool-btn" id="redoBtn" title="ã‚„ã‚Šç›´ã— (Ctrl+Shift+Z)">â†ª ã‚„ã‚Šç›´ã—</button>
            </div>
            <div class="tool-group">
                <button class="tool-btn" id="gridSettingsBtn" title="ã‚°ãƒªãƒƒãƒ‰è¨­å®š">âš™ ã‚°ãƒªãƒƒãƒ‰</button>
            </div>
            <div class="tool-group">
                <button class="tool-btn save-btn" id="saveBtn" title="ä¿å­˜ (Ctrl+S)">ğŸ’¾ ä¿å­˜</button>
            </div>
        </div>
        
        <!-- ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ -->
        <div class="main-content">
            <!-- ã‚µã‚¤ãƒ‰ãƒ‘ãƒãƒ«ï¼ˆæ§‹é€ ç‰©ãƒªã‚¹ãƒˆï¼‰ -->
            <div class="side-panel">
                <div class="panel-section">
                    <div class="panel-title">æ§‹é€ ç‰©ã‚¿ã‚¤ãƒ—</div>
                    <div class="structure-list" id="structureList">
                        <div class="structure-item" data-subtype="escalator">
                            <span class="structure-icon escalator">â†‘â†“</span>
                            <span>ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚¿ãƒ¼</span>
                        </div>
                        <div class="structure-item" data-subtype="stairs">
                            <span class="structure-icon stairs">éš</span>
                            <span>éšæ®µ</span>
                        </div>
                        <div class="structure-item" data-subtype="counter">
                            <span class="structure-icon counter">C</span>
                            <span>ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼</span>
                        </div>
                        <div class="structure-item" data-subtype="locker">
                            <span class="structure-icon locker">L</span>
                            <span>ãƒ­ãƒƒã‚«ãƒ¼</span>
                        </div>
                        <div class="structure-item" data-subtype="vending">
                            <span class="structure-icon vending">V</span>
                            <span>è‡ªè²©æ©Ÿ</span>
                        </div>
                        <div class="structure-item" data-subtype="shelf">
                            <span class="structure-icon shelf">æ£š</span>
                            <span>æ£š</span>
                        </div>
                        <div class="structure-item" data-subtype="pillar">
                            <span class="structure-icon pillar">â– </span>
                            <span>æŸ±</span>
                        </div>
                        <div class="structure-item selected" data-subtype="label">
                            <span class="structure-icon label">T</span>
                            <span>ãƒ©ãƒ™ãƒ«</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- ã‚°ãƒªãƒƒãƒ‰ã‚³ãƒ³ãƒ†ãƒŠ -->
            <div class="grid-container" id="gridContainer">
                <div class="editor-grid" id="editorGrid">
                    <!-- ã‚°ãƒªãƒƒãƒ‰ã¯JSã§ç”Ÿæˆ -->
                </div>
            </div>
            
            <!-- ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ‘ãƒãƒ« -->
            <div class="property-panel">
                <div class="panel-section">
                    <div class="panel-title">é¸æŠä¸­</div>
                    <div class="property-content" id="propertyContent">
                        <div style="color: var(--text-secondary); font-size: 12px;">
                            ã‚»ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼ -->
        <div class="status-bar">
            <div class="status-info">
                <span id="statusHole">åº—èˆ—: æœªé¸æŠ</span>
                <span id="statusGrid">ã‚°ãƒªãƒƒãƒ‰: -</span>
                <span id="statusCells">ã‚»ãƒ«æ•°: -</span>
                <span id="statusSource">ã‚½ãƒ¼ã‚¹: -</span>
            </div>
            <div id="statusMessage">ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„</div>
        </div>
    </div>
    
    <!-- å°ç•ªå·å…¥åŠ›ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="machineModal" class="modal-overlay">
        <div class="modal">
            <h3>å°ç•ªå·ã‚’å…¥åŠ›</h3>
            <input type="number" id="machineNumberInput" class="property-input" placeholder="ä¾‹: 1205">
            <div class="modal-buttons">
                <button class="modal-btn secondary" id="machineModalCancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                <button class="modal-btn primary" id="machineModalOk">è¿½åŠ </button>
            </div>
        </div>
    </div>
    
    <!-- ãƒ©ãƒ™ãƒ«å…¥åŠ›ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="labelModal" class="modal-overlay">
        <div class="modal">
            <h3 id="labelModalTitle">ãƒ©ãƒ™ãƒ«ã‚’å…¥åŠ›</h3>
            <input type="text" id="labelInput" class="property-input" placeholder="ä¾‹: POS">
            <div class="modal-buttons">
                <button class="modal-btn secondary" id="labelModalCancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                <button class="modal-btn primary" id="labelModalOk">è¿½åŠ </button>
            </div>
        </div>
    </div>
    
    <!-- ã‚°ãƒªãƒƒãƒ‰è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="gridModal" class="modal-overlay">
        <div class="modal">
            <h3>ã‚°ãƒªãƒƒãƒ‰è¨­å®š</h3>
            <div class="property-row">
                <label class="property-label">è¡Œæ•°</label>
                <input type="number" id="gridRowsInput" class="property-input" min="1" max="200">
            </div>
            <div class="property-row">
                <label class="property-label">åˆ—æ•°</label>
                <input type="number" id="gridColsInput" class="property-input" min="1" max="200">
            </div>
            <div class="modal-buttons">
                <button class="modal-btn secondary" id="gridModalCancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                <button class="modal-btn primary" id="gridModalOk">é©ç”¨</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // çŠ¶æ…‹ç®¡ç†
        // ============================================================================
        let layoutData = null;
        let currentTool = 'select';
        let selectedStructureType = 'label';
        let selectedCells = new Set();
        let undoStack = [];
        let redoStack = [];
        let isDirty = false;
        let layoutSource = null;
        
        // ãƒ‰ãƒ©ãƒƒã‚°é–¢é€£
        let isDragging = false;
        let dragStartCell = null;
        let draggedCells = [];
        
        // ç¯„å›²é¸æŠé–¢é€£
        let isRangeSelecting = false;
        let rangeSelectStart = null;
        let rangeSelectEnd = null;
        
        // ã‚»ãƒ«è¦ç´ ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆquerySelectorã‚’é¿ã‘ã‚‹ãŸã‚ï¼‰
        let cellElementCache = new Map(); // key: "row-col", value: DOM element
        
        // ============================================================================
        // åˆæœŸåŒ–
        // ============================================================================
        
        async function init() {
            // åº—èˆ—ä¸€è¦§ã‚’å–å¾—
            await loadHoleList();
            
            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            setupEventListeners();
        }
        
        async function loadHoleList() {
            try {
                const response = await fetch('/api/heatmap/layouts');
                const data = await response.json();
                
                const select = document.getElementById('holeSelect');
                data.layouts.forEach(layout => {
                    const option = document.createElement('option');
                    option.value = layout.hole;
                    option.textContent = `${layout.hole} (${layout.source || 'local'})`;
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('åº—èˆ—ä¸€è¦§å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
            }
        }
        
        function setupEventListeners() {
            // èª­ã¿è¾¼ã¿ãƒœã‚¿ãƒ³
            document.getElementById('loadBtn').addEventListener('click', loadLayout);
            
            // ä¿å­˜ãƒœã‚¿ãƒ³
            document.getElementById('saveBtn').addEventListener('click', saveLayout);
            
            // ãƒ„ãƒ¼ãƒ«ãƒœã‚¿ãƒ³
            document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                btn.addEventListener('click', () => selectTool(btn.dataset.tool));
            });
            
            // æ§‹é€ ç‰©ã‚¿ã‚¤ãƒ—é¸æŠ
            document.querySelectorAll('.structure-item').forEach(item => {
                item.addEventListener('click', () => selectStructureType(item.dataset.subtype));
            });
            
            // Undo/Redo
            document.getElementById('undoBtn').addEventListener('click', undo);
            document.getElementById('redoBtn').addEventListener('click', redo);
            
            // ã‚°ãƒªãƒƒãƒ‰è¨­å®š
            document.getElementById('gridSettingsBtn').addEventListener('click', showGridSettings);
            document.getElementById('gridModalCancel').addEventListener('click', () => closeModal('gridModal'));
            document.getElementById('gridModalOk').addEventListener('click', applyGridSettings);
            
            // å°ç•ªå·ãƒ¢ãƒ¼ãƒ€ãƒ«
            document.getElementById('machineModalCancel').addEventListener('click', () => closeModal('machineModal'));
            document.getElementById('machineModalOk').addEventListener('click', addMachineFromModal);
            document.getElementById('machineNumberInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addMachineFromModal();
            });
            
            // ãƒ©ãƒ™ãƒ«ãƒ¢ãƒ¼ãƒ€ãƒ«
            document.getElementById('labelModalCancel').addEventListener('click', () => closeModal('labelModal'));
            document.getElementById('labelModalOk').addEventListener('click', addLabelFromModal);
            document.getElementById('labelInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addLabelFromModal();
            });
            
            // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
            document.addEventListener('keydown', handleKeydown);
            
            // ã‚°ãƒªãƒƒãƒ‰ã®ã‚¤ãƒ™ãƒ³ãƒˆå§”è­²ï¼ˆã‚»ãƒ«ã”ã¨ã«ãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ ã™ã‚‹ä»£ã‚ã‚Šã«ã€ã‚°ãƒªãƒƒãƒ‰ã«1ã¤ã ã‘è¿½åŠ ï¼‰
            const grid = document.getElementById('editorGrid');
            grid.addEventListener('click', (e) => {
                const cell = e.target.closest('.editor-cell');
                if (!cell) return;
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                handleCellClick(e, row, col);
            });
            grid.addEventListener('mousedown', (e) => {
                const cell = e.target.closest('.editor-cell');
                if (!cell) return;
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                handleCellMouseDown(e, row, col);
            });
            grid.addEventListener('mouseenter', (e) => {
                const cell = e.target.closest('.editor-cell');
                if (!cell) return;
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                handleCellMouseEnter(e, row, col);
            }, true); // ã‚­ãƒ£ãƒ—ãƒãƒ£ãƒ•ã‚§ãƒ¼ã‚ºã§å‡¦ç†ï¼ˆå­è¦ç´ ã¸ã®enterã‚‚æ¤œçŸ¥ï¼‰
            grid.addEventListener('mouseup', (e) => {
                const cell = e.target.closest('.editor-cell');
                if (!cell) return;
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                handleCellMouseUp(e, row, col);
            });
            grid.addEventListener('mouseover', (e) => {
                const cell = e.target.closest('.editor-cell');
                if (!cell) return;
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                handleCellMouseEnter(e, row, col);
            });
        }
        
        // ============================================================================
        // ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆèª­ã¿è¾¼ã¿/ä¿å­˜
        // ============================================================================
        
        async function loadLayout() {
            const hole = document.getElementById('holeSelect').value;
            if (!hole) {
                alert('åº—èˆ—ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            try {
                const response = await fetch(`/api/heatmap/layouts/${encodeURIComponent(hole)}`);
                if (!response.ok) throw new Error('ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
                
                layoutData = await response.json();
                layoutSource = response.headers.get('X-Layout-Source') || 'unknown';
                
                // çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆ
                selectedCells.clear();
                undoStack = [];
                redoStack = [];
                isDirty = false;
                
                renderGrid();
                updateStatus();
                setMessage(`ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸï¼ˆ${layoutSource}ï¼‰`);
            } catch (error) {
                console.error('èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                alert('ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
            }
        }
        
        async function saveLayout() {
            if (!layoutData) {
                alert('ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“');
                return;
            }
            
            try {
                const response = await fetch(`/api/heatmap/layouts/${encodeURIComponent(layoutData.hole)}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(layoutData),
                });
                
                if (!response.ok) throw new Error('ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ');
                
                const result = await response.json();
                isDirty = false;
                layoutSource = 'gcs';
                updateStatus();
                setMessage(`ä¿å­˜ã—ã¾ã—ãŸï¼ˆ${result.cellCount}ã‚»ãƒ«ï¼‰`);
            } catch (error) {
                console.error('ä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
                alert('ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
            }
        }
        
        // ============================================================================
        // ã‚°ãƒªãƒƒãƒ‰æç”»
        // ============================================================================
        
        function renderGrid() {
            const grid = document.getElementById('editorGrid');
            grid.innerHTML = '';
            cellElementCache.clear(); // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢
            
            if (!layoutData) return;
            
            const { rows, cols } = layoutData.grid;
            grid.style.gridTemplateColumns = `repeat(${cols}, var(--cell-size))`;
            grid.style.gridTemplateRows = `repeat(${rows}, var(--cell-size))`;
            
            // ã‚»ãƒ«ãƒãƒƒãƒ—ã‚’ä½œæˆ
            const cellMap = new Map();
            const mergedCells = new Set(); // ãƒãƒ¼ã‚¸ã•ã‚ŒãŸå­ã‚»ãƒ«ã®ä½ç½®
            
            layoutData.cells.forEach(cell => {
                cellMap.set(`${cell.row}-${cell.col}`, cell);
                
                // ãƒãƒ¼ã‚¸ã•ã‚ŒãŸã‚»ãƒ«ã‚’ãƒãƒ¼ã‚¯
                if (cell.mergeRows > 1 || cell.mergeCols > 1) {
                    const mr = cell.mergeRows || 1;
                    const mc = cell.mergeCols || 1;
                    for (let r = 0; r < mr; r++) {
                        for (let c = 0; c < mc; c++) {
                            if (r !== 0 || c !== 0) {
                                mergedCells.add(`${cell.row + r}-${cell.col + c}`);
                            }
                        }
                    }
                }
            });
            
            // å£ãƒãƒƒãƒ—ã‚’ä½œæˆ
            const wallMap = new Map();
            (layoutData.walls || []).forEach(wall => {
                const key = `${wall.row}-${wall.col}`;
                if (!wallMap.has(key)) wallMap.set(key, []);
                wallMap.get(key).push(wall.side);
            });
            
            // ã‚°ãƒªãƒƒãƒ‰ã‚’ç”Ÿæˆ
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const key = `${row}-${col}`;
                    const cellData = cellMap.get(key);
                    const walls = wallMap.get(key) || [];
                    
                    // ãƒãƒ¼ã‚¸ã•ã‚ŒãŸå­ã‚»ãƒ«ã¯ã‚¹ã‚­ãƒƒãƒ—ï¼ˆè¦ªã‚»ãƒ«ãŒspanã§è¦†ã†ï¼‰
                    if (mergedCells.has(key)) {
                        continue;
                    }
                    
                    const cellElement = document.createElement('div');
                    cellElement.className = 'editor-cell';
                    cellElement.dataset.row = row;
                    cellElement.dataset.col = col;
                    
                    // å£ã‚¯ãƒ©ã‚¹ã‚’è¿½åŠ 
                    walls.forEach(side => {
                        cellElement.classList.add(`wall-${side}`);
                    });
                    
                    if (cellData) {
                        renderCellContent(cellElement, cellData);
                        
                        // ãƒãƒ¼ã‚¸ã•ã‚ŒãŸã‚»ãƒ«ï¼ˆè¦ªï¼‰ã¯å¤§ããè¡¨ç¤º
                        if (cellData.mergeRows > 1 || cellData.mergeCols > 1) {
                            const mr = cellData.mergeRows || 1;
                            const mc = cellData.mergeCols || 1;
                            cellElement.style.gridRow = `${row + 1} / span ${mr}`;
                            cellElement.style.gridColumn = `${col + 1} / span ${mc}`;
                            cellElement.classList.add('merged-parent');
                        } else {
                            cellElement.style.gridRow = String(row + 1);
                            cellElement.style.gridColumn = String(col + 1);
                        }
                    } else {
                        cellElement.style.gridRow = String(row + 1);
                        cellElement.style.gridColumn = String(col + 1);
                    }
                    
                    // é¸æŠçŠ¶æ…‹
                    if (selectedCells.has(key)) {
                        cellElement.classList.add('selected');
                    }
                    
                    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã¯ã‚¤ãƒ™ãƒ³ãƒˆå§”è­²ã§å‡¦ç†ï¼ˆsetupEventListenerså‚ç…§ï¼‰
                    
                    grid.appendChild(cellElement);
                    cellElementCache.set(key, cellElement); // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜
                }
            }
        }
        
        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰ã‚»ãƒ«è¦ç´ ã‚’å–å¾—ï¼ˆquerySelectorã®ä»£ã‚ã‚Šï¼‰
        function getCellElement(row, col) {
            return cellElementCache.get(`${row}-${col}`);
        }
        
        function renderCellContent(element, cellData) {
            const { type, subtype, number, text, label } = cellData;
            
            if (type === 'machine') {
                element.classList.add('machine');
                element.textContent = number;
            } else if (type === 'structure') {
                element.classList.add('structure', subtype || '');
                element.textContent = label || subtype || '';
            } else if (type === 'label') {
                element.classList.add('label');
                element.textContent = text || '';
            }
        }
        
        // ============================================================================
        // ãƒ„ãƒ¼ãƒ«æ“ä½œ
        // ============================================================================
        
        function selectTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tool === tool);
            });
            
            // é¸æŠè§£é™¤
            if (tool !== 'select') {
                selectedCells.clear();
                renderGrid();
            }
        }
        
        function selectStructureType(subtype) {
            selectedStructureType = subtype;
            document.querySelectorAll('.structure-item').forEach(item => {
                item.classList.toggle('selected', item.dataset.subtype === subtype);
            });
        }
        
        // ============================================================================
        // ã‚»ãƒ«ã‚¯ãƒªãƒƒã‚¯å‡¦ç†
        // ============================================================================
        
        function handleCellClick(e, row, col) {
            const key = `${row}-${col}`;
            
            switch (currentTool) {
                case 'select':
                    handleSelectClick(e, row, col, key);
                    break;
                case 'machine':
                    handleMachineClick(row, col, key);
                    break;
                case 'structure':
                    handleStructureClick(row, col, key);
                    break;
                case 'wall':
                    handleWallClick(e, row, col);
                    break;
                case 'eraser':
                    handleEraserClick(row, col, key);
                    break;
            }
        }
        
        function handleSelectClick(e, row, col, key) {
            if (e.shiftKey) {
                // è¤‡æ•°é¸æŠ
                if (selectedCells.has(key)) {
                    selectedCells.delete(key);
                } else {
                    selectedCells.add(key);
                }
            } else {
                // å˜ä¸€é¸æŠ
                selectedCells.clear();
                selectedCells.add(key);
            }
            
            renderGrid();
            updatePropertyPanel();
        }
        
        function handleMachineClick(row, col, key) {
            const existingCell = layoutData.cells.find(c => c.row === row && c.col === col);
            if (existingCell && existingCell.type === 'machine') {
                alert('ã“ã®ã‚»ãƒ«ã«ã¯æ—¢ã«å°ãŒã‚ã‚Šã¾ã™ã€‚å‰Šé™¤ã—ã¦ã‹ã‚‰è¿½åŠ ã—ã¦ãã ã•ã„ã€‚');
                return;
            }
            
            // æ§‹é€ ç‰©ã‚„ãƒ©ãƒ™ãƒ«ãŒã‚ã‚‹å ´åˆã¯å‰Šé™¤ã™ã‚‹
            if (existingCell) {
                const index = layoutData.cells.indexOf(existingCell);
                if (index >= 0) layoutData.cells.splice(index, 1);
            }
            
            // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤º
            pendingCellPosition = { row, col };
            document.getElementById('machineNumberInput').value = '';
            openModal('machineModal');
            document.getElementById('machineNumberInput').focus();
        }
        
        function handleStructureClick(row, col, key) {
            const existingCell = layoutData.cells.find(c => c.row === row && c.col === col);
            if (existingCell && existingCell.type === 'machine') {
                alert('ã“ã®ã‚»ãƒ«ã«ã¯å°ãŒã‚ã‚Šã¾ã™ã€‚å‰Šé™¤ã—ã¦ã‹ã‚‰è¿½åŠ ã—ã¦ãã ã•ã„ã€‚');
                return;
            }
            
            // æ—¢å­˜ã®æ§‹é€ ç‰©ã‚„ãƒ©ãƒ™ãƒ«ãŒã‚ã‚‹å ´åˆã¯å‰Šé™¤ã™ã‚‹
            if (existingCell) {
                saveState();
                const index = layoutData.cells.indexOf(existingCell);
                if (index >= 0) layoutData.cells.splice(index, 1);
            } else {
                saveState();
            }
            
            if (selectedStructureType === 'label') {
                // ãƒ©ãƒ™ãƒ«ã®å ´åˆã¯ãƒ¢ãƒ¼ãƒ€ãƒ«ã§å…¥åŠ›
                pendingCellPosition = { row, col };
                document.getElementById('labelInput').value = '';
                openModal('labelModal');
                document.getElementById('labelInput').focus();
            } else {
                // æ§‹é€ ç‰©ã‚’è¿½åŠ 
                layoutData.cells.push({
                    row, col,
                    type: 'structure',
                    subtype: selectedStructureType,
                });
                markDirty();
                renderGrid();
            }
        }
        
        // ç¯„å›²ã«æ§‹é€ ç‰©ã‚’é…ç½®
        function placeStructureInRange() {
            if (selectedCells.size < 2) return;
            
            // é¸æŠç¯„å›²ã®å¢ƒç•Œã‚’è¨ˆç®—
            let minRow = Infinity, maxRow = -Infinity;
            let minCol = Infinity, maxCol = -Infinity;
            
            selectedCells.forEach(key => {
                const [row, col] = key.split('-').map(Number);
                minRow = Math.min(minRow, row);
                maxRow = Math.max(maxRow, row);
                minCol = Math.min(minCol, col);
                maxCol = Math.max(maxCol, col);
            });
            
            // ç¯„å›²å†…ã«å°ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            let hasMachine = false;
            for (let r = minRow; r <= maxRow; r++) {
                for (let c = minCol; c <= maxCol; c++) {
                    const cell = layoutData.cells.find(cell => cell.row === r && cell.col === c);
                    if (cell && cell.type === 'machine') {
                        hasMachine = true;
                        break;
                    }
                }
                if (hasMachine) break;
            }
            
            if (hasMachine) {
                alert('é¸æŠç¯„å›²å†…ã«å°ãŒã‚ã‚Šã¾ã™ã€‚å…ˆã«å‰Šé™¤ã—ã¦ãã ã•ã„ã€‚');
                return;
            }
            
            // ãƒ©ãƒ™ãƒ«å…¥åŠ›ã‚’æ±‚ã‚ã‚‹ï¼ˆç¾åœ¨é¸æŠä¸­ã®æ§‹é€ ç‰©ã‚¿ã‚¤ãƒ—ã‚’ä½¿ç”¨ï¼‰
            pendingRangeSelection = { minRow, maxRow, minCol, maxCol, structureType: selectedStructureType };
            document.getElementById('labelInput').value = '';
            document.getElementById('labelModalTitle').textContent = 
                selectedStructureType === 'label' ? 'ãƒ©ãƒ™ãƒ«ã‚’å…¥åŠ›' : `${getStructureTypeName(selectedStructureType)}ã®ãƒ©ãƒ™ãƒ«ã‚’å…¥åŠ›`;
            openModal('labelModal');
            document.getElementById('labelInput').focus();
        }
        
        function getStructureTypeName(subtype) {
            const names = {
                escalator: 'ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚¿ãƒ¼',
                stairs: 'éšæ®µ',
                counter: 'ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼',
                locker: 'ãƒ­ãƒƒã‚«ãƒ¼',
                vending: 'è‡ªè²©æ©Ÿ',
                shelf: 'æ£š',
                pillar: 'æŸ±',
                label: 'ãƒ©ãƒ™ãƒ«',
            };
            return names[subtype] || subtype;
        }
        
        let pendingRangeSelection = null;
        
        function handleWallClick(e, row, col) {
            const cellElement = e.target.closest('.editor-cell');
            const rect = cellElement.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // ã‚¯ãƒªãƒƒã‚¯ä½ç½®ã‹ã‚‰è¾ºã‚’åˆ¤å®š
            const threshold = 10;
            let side = null;
            
            if (y < threshold) side = 'top';
            else if (y > rect.height - threshold) side = 'bottom';
            else if (x < threshold) side = 'left';
            else if (x > rect.width - threshold) side = 'right';
            
            if (!side) return;
            
            // å£ã®ãƒˆã‚°ãƒ«
            saveState();
            if (!layoutData.walls) layoutData.walls = [];
            
            const existingIndex = layoutData.walls.findIndex(w => 
                w.row === row && w.col === col && w.side === side
            );
            
            if (existingIndex >= 0) {
                layoutData.walls.splice(existingIndex, 1);
            } else {
                layoutData.walls.push({ row, col, side });
            }
            
            markDirty();
            renderGrid();
        }
        
        function handleEraserClick(row, col, key) {
            const cellIndex = layoutData.cells.findIndex(c => c.row === row && c.col === col);
            if (cellIndex >= 0) {
                saveState();
                layoutData.cells.splice(cellIndex, 1);
                markDirty();
                renderGrid();
            }
        }
        
        // ============================================================================
        // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—
        // ============================================================================
        
        function handleCellMouseDown(e, row, col) {
            if (currentTool === 'select') {
                const key = `${row}-${col}`;
                const cellData = layoutData.cells.find(c => c.row === row && c.col === col);
                
                if (cellData && selectedCells.has(key) && !e.shiftKey) {
                    // é¸æŠæ¸ˆã¿ã‚»ãƒ«ã‚’ãƒ‰ãƒ©ãƒƒã‚°ç§»å‹•
                    isDragging = true;
                    dragStartCell = { row, col };
                    draggedCells = Array.from(selectedCells).map(k => {
                        const [r, c] = k.split('-').map(Number);
                        return layoutData.cells.find(cell => cell.row === r && cell.col === c);
                    }).filter(Boolean);
                    e.preventDefault();
                } else {
                    // ç¯„å›²é¸æŠé–‹å§‹
                    isRangeSelecting = true;
                    rangeSelectStart = { row, col };
                    rangeSelectEnd = { row, col };
                    if (!e.shiftKey) {
                        // å‰ã®é¸æŠã‚’è§£é™¤ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä½¿ç”¨ï¼‰
                        selectedCells.forEach(k => {
                            const el = cellElementCache.get(k);
                            if (el) el.classList.remove('selected');
                        });
                        selectedCells.clear();
                    }
                    selectedCells.add(key);
                    // ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‚»ãƒ«ã ã‘é¸æŠï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä½¿ç”¨ï¼‰
                    const clickedEl = cellElementCache.get(key);
                    if (clickedEl) clickedEl.classList.add('selected');
                    e.preventDefault();
                }
            } else if (currentTool === 'structure') {
                // æ§‹é€ ç‰©ãƒ„ãƒ¼ãƒ«ã§ã‚‚ç¯„å›²é¸æŠ
                isRangeSelecting = true;
                rangeSelectStart = { row, col };
                rangeSelectEnd = { row, col };
                const key = `${row}-${col}`;
                // å‰ã®é¸æŠã‚’è§£é™¤ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä½¿ç”¨ï¼‰
                selectedCells.forEach(k => {
                    const el = cellElementCache.get(k);
                    if (el) el.classList.remove('selected');
                });
                selectedCells.clear();
                selectedCells.add(key);
                // ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‚»ãƒ«ã ã‘é¸æŠï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä½¿ç”¨ï¼‰
                const clickedEl = cellElementCache.get(key);
                if (clickedEl) clickedEl.classList.add('selected');
                e.preventDefault();
            }
        }
        
        // ãƒ‰ãƒ©ãƒƒã‚°æ™‚ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆå¯¾è±¡ã‚»ãƒ«ã‚’è¿½è·¡
        let dragOverCells = new Set();
        
        function handleCellMouseEnter(e, row, col) {
            // ç¯„å›²é¸æŠä¸­
            if (isRangeSelecting) {
                rangeSelectEnd = { row, col };
                updateRangeSelection();
                return;
            }
            
            // ãƒ‰ãƒ©ãƒƒã‚°ç§»å‹•ä¸­
            if (!isDragging) return;
            
            // å‰å›ã®ãƒ‰ãƒ©ãƒƒã‚°ã‚ªãƒ¼ãƒãƒ¼ã‚’è§£é™¤ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä½¿ç”¨ï¼‰
            dragOverCells.forEach(key => {
                const el = cellElementCache.get(key);
                if (el) el.classList.remove('drag-over');
            });
            dragOverCells.clear();
            
            // ãƒ‰ãƒ­ãƒƒãƒ—å…ˆã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä½¿ç”¨ï¼‰
            const offsetRow = row - dragStartCell.row;
            const offsetCol = col - dragStartCell.col;
            
            draggedCells.forEach(cell => {
                const newRow = cell.row + offsetRow;
                const newCol = cell.col + offsetCol;
                const key = `${newRow}-${newCol}`;
                const targetCell = cellElementCache.get(key);
                if (targetCell) {
                    targetCell.classList.add('drag-over');
                    dragOverCells.add(key);
                }
            });
        }
        
        // ã‚¹ãƒ­ãƒƒãƒˆãƒªãƒ³ã‚°ç”¨
        let rangeSelectionPending = false;
        
        function updateRangeSelection() {
            if (!rangeSelectStart || !rangeSelectEnd) return;
            
            // å‰å›ã®æ›´æ–°ãŒã¾ã å‡¦ç†ä¸­ãªã‚‰æ–°ã—ã„ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ã‚­ãƒ¥ãƒ¼ã‚¤ãƒ³ã‚°
            if (rangeSelectionPending) return;
            rangeSelectionPending = true;
            
            requestAnimationFrame(() => {
                rangeSelectionPending = false;
                if (!rangeSelectStart || !rangeSelectEnd) return;
                
                const minRow = Math.min(rangeSelectStart.row, rangeSelectEnd.row);
                const maxRow = Math.max(rangeSelectStart.row, rangeSelectEnd.row);
                const minCol = Math.min(rangeSelectStart.col, rangeSelectEnd.col);
                const maxCol = Math.max(rangeSelectStart.col, rangeSelectEnd.col);
                
                // å‰ã®é¸æŠã‚’è§£é™¤ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä½¿ç”¨ï¼‰
                selectedCells.forEach(key => {
                    const el = cellElementCache.get(key);
                    if (el) el.classList.remove('selected');
                });
                
                selectedCells.clear();
                
                // æ–°ã—ã„é¸æŠã‚’è¿½åŠ ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä½¿ç”¨ï¼‰
                for (let r = minRow; r <= maxRow; r++) {
                    for (let c = minCol; c <= maxCol; c++) {
                        const key = `${r}-${c}`;
                        selectedCells.add(key);
                        const el = cellElementCache.get(key);
                        if (el) el.classList.add('selected');
                    }
                }
            });
        }
        
        function handleCellMouseUp(e, row, col) {
            // ç¯„å›²é¸æŠçµ‚äº†
            if (isRangeSelecting) {
                const wasSingleCell = selectedCells.size === 1;
                const tool = currentTool;
                
                isRangeSelecting = false;
                rangeSelectStart = null;
                rangeSelectEnd = null;
                
                // æ§‹é€ ç‰©ãƒ„ãƒ¼ãƒ«ã§å˜ä¸€ã‚»ãƒ«ã®å ´åˆã¯ç›´æ¥é…ç½®
                if (tool === 'structure' && wasSingleCell) {
                    const key = Array.from(selectedCells)[0];
                    const [r, c] = key.split('-').map(Number);
                    selectedCells.clear();
                    renderGrid();
                    handleStructureClick(r, c, key);
                    return;
                }
                
                updatePropertyPanel();
                return;
            }
            
            if (!isDragging) return;
            
            const offsetRow = row - dragStartCell.row;
            const offsetCol = col - dragStartCell.col;
            
            if (offsetRow !== 0 || offsetCol !== 0) {
                // ç§»å‹•å…ˆãŒæœ‰åŠ¹ã‹ãƒã‚§ãƒƒã‚¯
                let canMove = true;
                const newPositions = draggedCells.map(cell => ({
                    row: cell.row + offsetRow,
                    col: cell.col + offsetCol,
                }));
                
                newPositions.forEach(pos => {
                    if (pos.row < 0 || pos.row >= layoutData.grid.rows ||
                        pos.col < 0 || pos.col >= layoutData.grid.cols) {
                        canMove = false;
                    }
                    
                    // ç§»å‹•å…ˆã«ä»–ã®ã‚»ãƒ«ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆè‡ªåˆ†è‡ªèº«ã¯é™¤ãï¼‰
                    const existingCell = layoutData.cells.find(c => 
                        c.row === pos.row && c.col === pos.col &&
                        !draggedCells.includes(c)
                    );
                    if (existingCell) {
                        canMove = false;
                    }
                });
                
                if (canMove) {
                    saveState();
                    draggedCells.forEach((cell, i) => {
                        cell.row = newPositions[i].row;
                        cell.col = newPositions[i].col;
                    });
                    
                    // é¸æŠçŠ¶æ…‹ã‚’æ›´æ–°
                    selectedCells.clear();
                    newPositions.forEach(pos => {
                        selectedCells.add(`${pos.row}-${pos.col}`);
                    });
                    
                    markDirty();
                }
            }
            
            // ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†
            isDragging = false;
            dragStartCell = null;
            draggedCells = [];
            
            // ãƒ‰ãƒ©ãƒƒã‚°ã‚ªãƒ¼ãƒãƒ¼ã‚’è§£é™¤ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä½¿ç”¨ï¼‰
            dragOverCells.forEach(key => {
                const el = cellElementCache.get(key);
                if (el) el.classList.remove('drag-over');
            });
            dragOverCells.clear();
            
            renderGrid();
        }
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã®mouseupï¼ˆã‚°ãƒªãƒƒãƒ‰å¤–ã§ã®ãƒã‚¦ã‚¹ã‚¢ãƒƒãƒ—å¯¾å¿œï¼‰
        document.addEventListener('mouseup', () => {
            if (isRangeSelecting) {
                isRangeSelecting = false;
                rangeSelectStart = null;
                rangeSelectEnd = null;
                updatePropertyPanel();
            }
        });
        
        // ============================================================================
        // ãƒ¢ãƒ¼ãƒ€ãƒ«
        // ============================================================================
        
        let pendingCellPosition = null;
        
        function openModal(id) {
            document.getElementById(id).classList.add('active');
        }
        
        function closeModal(id) {
            document.getElementById(id).classList.remove('active');
            pendingCellPosition = null;
        }
        
        function addMachineFromModal() {
            const numberInput = document.getElementById('machineNumberInput');
            const number = parseInt(numberInput.value);
            
            if (!number || number < 100 || number > 9999) {
                alert('æœ‰åŠ¹ãªå°ç•ªå·ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆ100-9999ï¼‰');
                return;
            }
            
            saveState();
            layoutData.cells.push({
                row: pendingCellPosition.row,
                col: pendingCellPosition.col,
                type: 'machine',
                number,
            });
            
            markDirty();
            closeModal('machineModal');
            renderGrid();
        }
        
        function addLabelFromModal() {
            const labelInput = document.getElementById('labelInput');
            const text = labelInput.value.trim();
            
            // ç¯„å›²é¸æŠã®å ´åˆ
            if (pendingRangeSelection) {
                const { minRow, maxRow, minCol, maxCol, structureType } = pendingRangeSelection;
                const mergeRows = maxRow - minRow + 1;
                const mergeCols = maxCol - minCol + 1;
                
                saveState();
                
                // ç¯„å›²å†…ã®æ—¢å­˜ã‚»ãƒ«ã‚’å‰Šé™¤
                for (let r = minRow; r <= maxRow; r++) {
                    for (let c = minCol; c <= maxCol; c++) {
                        const index = layoutData.cells.findIndex(cell => cell.row === r && cell.col === c);
                        if (index >= 0) layoutData.cells.splice(index, 1);
                    }
                }
                
                // çµåˆã•ã‚ŒãŸæ§‹é€ ç‰©ã‚’è¿½åŠ ï¼ˆå·¦ä¸Šã®ã‚»ãƒ«ã«é…ç½®ï¼‰
                if (structureType === 'label') {
                    layoutData.cells.push({
                        row: minRow,
                        col: minCol,
                        type: 'label',
                        text: text || '',
                        mergeRows,
                        mergeCols,
                    });
                } else {
                    layoutData.cells.push({
                        row: minRow,
                        col: minCol,
                        type: 'structure',
                        subtype: structureType,
                        label: text || '',
                        mergeRows,
                        mergeCols,
                    });
                }
                
                pendingRangeSelection = null;
                selectedCells.clear();
                markDirty();
                closeModal('labelModal');
                document.getElementById('labelModalTitle').textContent = 'ãƒ©ãƒ™ãƒ«ã‚’å…¥åŠ›';
                renderGrid();
                return;
            }
            
            // å˜ä¸€ã‚»ãƒ«ã®å ´åˆ
            if (!text) {
                alert('ãƒ©ãƒ™ãƒ«ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            saveState();
            layoutData.cells.push({
                row: pendingCellPosition.row,
                col: pendingCellPosition.col,
                type: 'label',
                text,
            });
            
            markDirty();
            closeModal('labelModal');
            renderGrid();
        }
        
        function showGridSettings() {
            if (!layoutData) return;
            
            document.getElementById('gridRowsInput').value = layoutData.grid.rows;
            document.getElementById('gridColsInput').value = layoutData.grid.cols;
            openModal('gridModal');
        }
        
        function applyGridSettings() {
            const rows = parseInt(document.getElementById('gridRowsInput').value);
            const cols = parseInt(document.getElementById('gridColsInput').value);
            
            if (!rows || !cols || rows < 1 || cols < 1) {
                alert('æœ‰åŠ¹ãªå€¤ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            saveState();
            layoutData.grid.rows = rows;
            layoutData.grid.cols = cols;
            
            // ç¯„å›²å¤–ã®ã‚»ãƒ«ã‚’å‰Šé™¤
            layoutData.cells = layoutData.cells.filter(c => 
                c.row < rows && c.col < cols
            );
            
            markDirty();
            closeModal('gridModal');
            renderGrid();
            updateStatus();
        }
        
        // ============================================================================
        // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ‘ãƒãƒ«
        // ============================================================================
        
        function updatePropertyPanel() {
            const content = document.getElementById('propertyContent');
            
            if (selectedCells.size === 0) {
                content.innerHTML = '<div style="color: var(--text-secondary); font-size: 12px;">ã‚»ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„</div>';
                return;
            }
            
            if (selectedCells.size === 1) {
                const key = Array.from(selectedCells)[0];
                const [row, col] = key.split('-').map(Number);
                const cellData = layoutData.cells.find(c => c.row === row && c.col === col);
                
                if (cellData) {
                    content.innerHTML = renderCellProperties(cellData, row, col);
                    setupPropertyEvents(cellData);
                } else {
                    content.innerHTML = `
                        <div class="property-row">
                            <span class="property-label">ä½ç½®</span>
                            <span class="property-value">è¡Œ ${row}, åˆ— ${col}</span>
                        </div>
                        <div style="color: var(--text-secondary); font-size: 12px;">ç©ºã®ã‚»ãƒ«</div>
                    `;
                }
            } else {
                // ç¯„å›²é¸æŠæ™‚
                const keys = Array.from(selectedCells);
                const rows = keys.map(k => parseInt(k.split('-')[0]));
                const cols = keys.map(k => parseInt(k.split('-')[1]));
                const minRow = Math.min(...rows);
                const maxRow = Math.max(...rows);
                const minCol = Math.min(...cols);
                const maxCol = Math.max(...cols);
                
                content.innerHTML = `
                    <div class="property-row">
                        <span class="property-label">é¸æŠç¯„å›²</span>
                        <span class="property-value">${maxRow - minRow + 1}è¡Œ Ã— ${maxCol - minCol + 1}åˆ—</span>
                    </div>
                    <div class="property-row">
                        <span class="property-label">ã‚»ãƒ«æ•°</span>
                        <span class="property-value">${selectedCells.size}ã‚»ãƒ«</span>
                    </div>
                    <button class="property-btn" id="placeStructureBtn" style="background-color: var(--accent-blue); border-color: var(--accent-blue); color: white; margin-bottom: 8px;">
                        æ§‹é€ ç‰©ã‚’é…ç½®
                    </button>
                    <button class="property-btn danger" id="deleteSelectedBtn">é¸æŠã‚’å‰Šé™¤</button>
                `;
                document.getElementById('deleteSelectedBtn')?.addEventListener('click', deleteSelected);
                document.getElementById('placeStructureBtn')?.addEventListener('click', placeStructureInRange);
            }
        }
        
        function renderCellProperties(cellData, row, col) {
            let html = `
                <div class="property-row">
                    <span class="property-label">ä½ç½®</span>
                    <span class="property-value">è¡Œ ${row}, åˆ— ${col}</span>
                </div>
            `;
            
            if (cellData.type === 'machine') {
                html += `
                    <div class="property-row">
                        <label class="property-label">å°ç•ªå·</label>
                        <input type="number" id="propMachineNumber" class="property-input" value="${cellData.number}">
                    </div>
                `;
            } else if (cellData.type === 'structure') {
                html += `
                    <div class="property-row">
                        <span class="property-label">ã‚¿ã‚¤ãƒ—</span>
                        <span class="property-value">${cellData.subtype}</span>
                    </div>
                    <div class="property-row">
                        <label class="property-label">ãƒ©ãƒ™ãƒ«</label>
                        <input type="text" id="propLabel" class="property-input" value="${cellData.label || ''}">
                    </div>
                `;
            } else if (cellData.type === 'label') {
                html += `
                    <div class="property-row">
                        <label class="property-label">ãƒ†ã‚­ã‚¹ãƒˆ</label>
                        <input type="text" id="propText" class="property-input" value="${cellData.text || ''}">
                    </div>
                `;
            }
            
            html += '<button class="property-btn danger" id="deleteCellBtn">å‰Šé™¤</button>';
            
            return html;
        }
        
        function setupPropertyEvents(cellData) {
            document.getElementById('deleteCellBtn')?.addEventListener('click', () => {
                saveState(); // å‰Šé™¤ã¯å³æ™‚ä¿å­˜
                const index = layoutData.cells.indexOf(cellData);
                if (index >= 0) {
                    layoutData.cells.splice(index, 1);
                    selectedCells.clear();
                    markDirty();
                    renderGrid();
                    updatePropertyPanel();
                }
            });
            
            // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£å¤‰æ›´ã¯ãƒ‡ãƒã‚¦ãƒ³ã‚¹ã§ä¿å­˜ï¼ˆé€£ç¶šå…¥åŠ›å¯¾å¿œï¼‰
            document.getElementById('propMachineNumber')?.addEventListener('change', (e) => {
                saveStateDebounced();
                cellData.number = parseInt(e.target.value);
                markDirty();
                renderGrid();
            });
            
            document.getElementById('propLabel')?.addEventListener('change', (e) => {
                saveStateDebounced();
                cellData.label = e.target.value;
                markDirty();
                renderGrid();
            });
            
            document.getElementById('propText')?.addEventListener('change', (e) => {
                saveStateDebounced();
                cellData.text = e.target.value;
                markDirty();
                renderGrid();
            });
        }
        
        function deleteSelected() {
            if (selectedCells.size === 0) return;
            
            saveState();
            selectedCells.forEach(key => {
                const [row, col] = key.split('-').map(Number);
                const index = layoutData.cells.findIndex(c => c.row === row && c.col === col);
                if (index >= 0) {
                    layoutData.cells.splice(index, 1);
                }
            });
            
            selectedCells.clear();
            markDirty();
            renderGrid();
            updatePropertyPanel();
        }
        
        // ============================================================================
        // Undo/Redo
        // ============================================================================
        
        // å³æ™‚ä¿å­˜ï¼ˆã‚¯ãƒªãƒƒã‚¯æ“ä½œãªã©ï¼‰
        function saveState() {
            // ãƒ‡ãƒã‚¦ãƒ³ã‚¹ä¸­ã®ã‚¿ã‚¤ãƒãƒ¼ãŒã‚ã‚Œã°ã‚­ãƒ£ãƒ³ã‚»ãƒ«
            if (saveStateTimer) {
                clearTimeout(saveStateTimer);
                saveStateTimer = null;
            }
            undoStack.push(JSON.stringify(layoutData));
            redoStack = [];
            
            // ã‚¹ã‚¿ãƒƒã‚¯ã‚µã‚¤ã‚ºã‚’åˆ¶é™
            if (undoStack.length > 50) {
                undoStack.shift();
            }
        }
        
        // ãƒ‡ãƒã‚¦ãƒ³ã‚¹ä¿å­˜ï¼ˆãƒ—ãƒ­ãƒ‘ãƒ†ã‚£å¤‰æ›´ãªã©é€£ç¶šå…¥åŠ›æ™‚ï¼‰
        let saveStateTimer = null;
        function saveStateDebounced() {
            if (saveStateTimer) clearTimeout(saveStateTimer);
            saveStateTimer = setTimeout(() => {
                saveStateTimer = null;
                undoStack.push(JSON.stringify(layoutData));
                redoStack = [];
                if (undoStack.length > 50) undoStack.shift();
            }, 300);
        }
        
        function undo() {
            if (undoStack.length === 0) return;
            
            redoStack.push(JSON.stringify(layoutData));
            layoutData = JSON.parse(undoStack.pop());
            selectedCells.clear();
            markDirty();
            renderGrid();
            updatePropertyPanel();
        }
        
        function redo() {
            if (redoStack.length === 0) return;
            
            undoStack.push(JSON.stringify(layoutData));
            layoutData = JSON.parse(redoStack.pop());
            selectedCells.clear();
            markDirty();
            renderGrid();
            updatePropertyPanel();
        }
        
        // ============================================================================
        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
        // ============================================================================
        
        function handleKeydown(e) {
            // ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒé–‹ã„ã¦ã„ã‚‹å ´åˆã¯ç„¡è¦–
            if (document.querySelector('.modal-overlay.active')) return;
            
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 's') {
                    e.preventDefault();
                    saveLayout();
                } else if (e.key === 'z') {
                    e.preventDefault();
                    if (e.shiftKey) {
                        redo();
                    } else {
                        undo();
                    }
                }
            } else {
                switch (e.key) {
                    case 'Delete':
                    case 'Backspace':
                        if (selectedCells.size > 0) {
                            e.preventDefault();
                            deleteSelected();
                        }
                        break;
                    case 'Escape':
                        selectedCells.clear();
                        renderGrid();
                        updatePropertyPanel();
                        break;
                    case 'v':
                        selectTool('select');
                        break;
                    case 'm':
                        selectTool('machine');
                        break;
                    case 's':
                        selectTool('structure');
                        break;
                    case 'w':
                        selectTool('wall');
                        break;
                    case 'e':
                        selectTool('eraser');
                        break;
                }
            }
        }
        
        // ============================================================================
        // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
        // ============================================================================
        
        function markDirty() {
            isDirty = true;
            updateStatus();
        }
        
        function updateStatus() {
            if (!layoutData) {
                document.getElementById('statusHole').textContent = 'åº—èˆ—: æœªé¸æŠ';
                document.getElementById('statusGrid').textContent = 'ã‚°ãƒªãƒƒãƒ‰: -';
                document.getElementById('statusCells').textContent = 'ã‚»ãƒ«æ•°: -';
                document.getElementById('statusSource').textContent = 'ã‚½ãƒ¼ã‚¹: -';
                return;
            }
            
            document.getElementById('statusHole').textContent = `åº—èˆ—: ${layoutData.hole}`;
            document.getElementById('statusGrid').textContent = `ã‚°ãƒªãƒƒãƒ‰: ${layoutData.grid.rows}Ã—${layoutData.grid.cols}`;
            document.getElementById('statusCells').textContent = `ã‚»ãƒ«æ•°: ${layoutData.cells.length}`;
            document.getElementById('statusSource').textContent = `ã‚½ãƒ¼ã‚¹: ${layoutSource || 'unknown'}`;
            
            if (isDirty) {
                document.getElementById('statusMessage').textContent = 'æœªä¿å­˜ã®å¤‰æ›´ãŒã‚ã‚Šã¾ã™';
            }
        }
        
        function setMessage(msg) {
            document.getElementById('statusMessage').textContent = msg;
        }
        
        // ============================================================================
        // åˆæœŸåŒ–å®Ÿè¡Œ
        // ============================================================================
        init();
    </script>
</body>
</html>
