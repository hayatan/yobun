<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>„É¨„Ç§„Ç¢„Ç¶„ÉàÁ∑®ÈõÜ - Yobun</title>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --border-color: #30363d;
            --text-primary: #c9d1d9;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-yellow: #d29922;
            --accent-red: #f85149;
            --accent-orange: #f0883e;
            --cell-size: 40px;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.5;
            height: 100vh;
            overflow: hidden;
        }
        
        /* „É¨„Ç§„Ç¢„Ç¶„Éà */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        /* „Éò„ÉÉ„ÉÄ„Éº */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 16px;
            background-color: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        
        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        h1 {
            font-size: 16px;
            font-weight: 600;
        }
        
        .header-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        select {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            padding: 6px 10px;
            font-size: 13px;
        }
        
        nav {
            display: flex;
            gap: 12px;
        }
        
        nav a {
            color: var(--accent-blue);
            text-decoration: none;
            font-size: 13px;
        }
        
        /* „ÉÑ„Éº„É´„Éê„Éº */
        .toolbar {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background-color: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        
        .tool-group {
            display: flex;
            gap: 4px;
            padding-right: 12px;
            border-right: 1px solid var(--border-color);
        }
        
        .tool-group:last-child {
            border-right: none;
        }
        
        .tool-btn {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .tool-btn:hover {
            background-color: #2d333b;
        }
        
        .tool-btn.active {
            background-color: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }
        
        .tool-btn.save-btn {
            background-color: var(--accent-green);
            border-color: var(--accent-green);
            color: white;
        }
        
        .tool-btn.save-btn:hover {
            opacity: 0.9;
        }
        
        /* „É°„Ç§„É≥„Ç≥„É≥„ÉÜ„É≥„ÉÑ */
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        /* „Çµ„Ç§„Éâ„Éë„Éç„É´ */
        .side-panel {
            width: 180px;
            background-color: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }
        
        .panel-section {
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .panel-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 8px;
        }
        
        .structure-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .structure-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }
        
        .structure-item:hover {
            border-color: var(--accent-blue);
        }
        
        .structure-item.selected {
            border-color: var(--accent-blue);
            background-color: rgba(88, 166, 255, 0.1);
        }
        
        .structure-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            font-size: 10px;
        }
        
        .structure-icon.escalator { background-color: #2a4a5a; }
        .structure-icon.stairs { background-color: #2a4a5a; }
        .structure-icon.counter { background-color: #5a4a3a; }
        .structure-icon.locker { background-color: #4a3a5a; }
        .structure-icon.vending { background-color: #3a5a4a; }
        .structure-icon.shelf { background-color: #4a4535; }
        .structure-icon.pillar { background-color: #5a5a5a; }
        .structure-icon.label { background-color: #2a2f38; }
        
        /* „Ç∞„É™„ÉÉ„Éâ„Ç≥„É≥„ÉÜ„Éä */
        .grid-container {
            flex: 1;
            overflow: hidden;
            padding: 16px;
            background-color: var(--bg-primary);
            touch-action: none;
        }
        
        .editor-grid {
            display: grid;
            gap: 1px;
            background-color: var(--border-color);
            width: fit-content;
            border: 1px solid var(--border-color);
        }
        
        /* „Çª„É´ */
        .editor-cell {
            min-width: var(--cell-size);
            min-height: var(--cell-size);
            background-color: var(--bg-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            cursor: pointer;
            position: relative;
            user-select: none;
        }
        
        .editor-cell:hover {
            outline: 2px solid var(--accent-blue);
            outline-offset: -2px;
            z-index: 1;
        }
        
        .editor-cell.selected {
            outline: 2px solid var(--accent-green);
            outline-offset: -2px;
            z-index: 2;
        }
        
        .editor-cell.machine {
            background-color: var(--bg-tertiary);
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .editor-cell.structure {
            background-color: #3d4450;
            color: #a0aab8;
        }
        
        .editor-cell.structure.escalator { background-color: #2a4a5a; }
        .editor-cell.structure.stairs { background-color: #2a4a5a; }
        .editor-cell.structure.counter { background-color: #5a4a3a; }
        .editor-cell.structure.locker { background-color: #4a3a5a; }
        .editor-cell.structure.vending { background-color: #3a5a4a; }
        .editor-cell.structure.shelf { background-color: #4a4535; }
        .editor-cell.structure.pillar { background-color: #5a5a5a; }
        
        .editor-cell.label {
            background-color: #2a2f38;
            color: #8090a0;
        }
        
        
        /* „Éó„É≠„Éë„ÉÜ„Ç£„Éë„Éç„É´ */
        .property-panel {
            width: 220px;
            background-color: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }
        
        .property-content {
            padding: 12px;
        }
        
        .property-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 12px;
        }
        
        .property-label {
            font-size: 11px;
            color: var(--text-secondary);
        }
        
        .property-value {
            font-size: 13px;
            color: var(--text-primary);
        }
        
        .property-input {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            padding: 6px 8px;
            font-size: 13px;
            width: 100%;
        }
        
        .property-btn {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            width: 100%;
            margin-top: 4px;
        }
        
        .property-btn:hover {
            background-color: #2d333b;
        }
        
        .property-btn.danger {
            background-color: rgba(248, 81, 73, 0.2);
            border-color: var(--accent-red);
            color: var(--accent-red);
        }
        
        /* „Çπ„ÉÜ„Éº„Çø„Çπ„Éê„Éº */
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 16px;
            background-color: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            font-size: 11px;
            color: var(--text-secondary);
            flex-shrink: 0;
        }
        
        .status-info {
            display: flex;
            gap: 16px;
        }
        
        /* „É¢„Éº„ÉÄ„É´ */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .modal-overlay.active {
            display: flex;
        }
        
        .modal {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            min-width: 300px;
        }
        
        .modal h3 {
            margin-bottom: 16px;
            font-size: 16px;
        }
        
        .modal-buttons {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            margin-top: 16px;
        }
        
        .modal-btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            border: 1px solid var(--border-color);
        }
        
        .modal-btn.primary {
            background-color: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }
        
        .modal-btn.secondary {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        /* „Éâ„É©„ÉÉ„Ç∞‰∏≠„ÅÆ„Çπ„Çø„Ç§„É´ */
        .editor-cell.dragging {
            opacity: 0.5;
        }
        
        .editor-cell.drag-over {
            background-color: rgba(88, 166, 255, 0.3) !important;
        }
        
        /* „Éû„Éº„Ç∏„Åï„Çå„Åü„Çª„É´ */
        .editor-cell.merged-parent {
            font-size: 11px;
            padding: 8px;
            text-align: center;
            word-break: break-all;
        }
        
    </style>
</head>
<body>
    <div class="app-container">
        <!-- „Éò„ÉÉ„ÉÄ„Éº -->
        <header>
            <div class="header-left">
                <h1>„É¨„Ç§„Ç¢„Ç¶„ÉàÁ∑®ÈõÜ</h1>
                <div class="header-controls">
                    <select id="holeSelect">
                        <option value="">Â∫óËàó„ÇíÈÅ∏Êäû</option>
                    </select>
                    <button class="tool-btn" id="loadBtn">Ë™≠„ÅøËæº„Åø</button>
                </div>
            </div>
            <nav>
                <a href="/heatmap">„Éí„Éº„Éà„Éû„ÉÉ„ÉóË°®Á§∫</a>
                <a href="/dashboard">„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ</a>
            </nav>
        </header>
        
        <!-- „ÉÑ„Éº„É´„Éê„Éº -->
        <div class="toolbar">
            <div class="tool-group">
                <button class="tool-btn" id="undoBtn" title="ÂÖÉ„Å´Êàª„Åô (Ctrl+Z)">‚Ü© Êàª„Åô</button>
                <button class="tool-btn" id="redoBtn" title="„ÇÑ„ÇäÁõ¥„Åó (Ctrl+Shift+Z)">‚Ü™ „ÇÑ„ÇäÁõ¥„Åó</button>
            </div>
            <div class="tool-group">
                <button class="tool-btn" id="zoomOutBtn" title="Á∏ÆÂ∞è">‚àí</button>
                <span id="zoomLevel" style="min-width: 50px; text-align: center; padding: 0 8px;">100%</span>
                <button class="tool-btn" id="zoomInBtn" title="Êã°Â§ß">+</button>
                <button class="tool-btn" id="zoomResetBtn" title="„É™„Çª„ÉÉ„Éà">‚ü≤</button>
            </div>
            <div class="tool-group">
                <button class="tool-btn" id="gridSettingsBtn" title="„Ç∞„É™„ÉÉ„ÉâË®≠ÂÆö">‚öô „Ç∞„É™„ÉÉ„Éâ</button>
            </div>
            <div class="tool-group">
                <button class="tool-btn save-btn" id="saveBtn" title="‰øùÂ≠ò (Ctrl+S)">üíæ ‰øùÂ≠ò</button>
            </div>
            <span id="fpsCounter" style="display: none; margin-left: auto; font-size: 11px; color: var(--accent-green); font-family: monospace; min-width: 60px; text-align: right;">-- FPS</span>
        </div>
        
        <!-- „É°„Ç§„É≥„Ç≥„É≥„ÉÜ„É≥„ÉÑ -->
        <div class="main-content">
            <!-- „Çµ„Ç§„Éâ„Éë„Éç„É´Ôºà„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„É™„Çπ„ÉàÔºâ -->
            <div class="side-panel">
                <div class="panel-section">
                    <div class="panel-title">„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çø„Ç§„Éó</div>
                    <div class="structure-list" id="structureList">
                        <div class="structure-item selected" data-subtype="machine">
                            <span class="structure-icon machine">üé∞</span>
                            <span>Âè∞</span>
                        </div>
                        <div class="structure-item" data-subtype="escalator">
                            <span class="structure-icon escalator">‚Üë‚Üì</span>
                            <span>„Ç®„Çπ„Ç´„É¨„Éº„Çø„Éº</span>
                        </div>
                        <div class="structure-item" data-subtype="stairs">
                            <span class="structure-icon stairs">Èöé</span>
                            <span>ÈöéÊÆµ</span>
                        </div>
                        <div class="structure-item" data-subtype="counter">
                            <span class="structure-icon counter">C</span>
                            <span>„Ç´„Ç¶„É≥„Çø„Éº</span>
                        </div>
                        <div class="structure-item" data-subtype="locker">
                            <span class="structure-icon locker">L</span>
                            <span>„É≠„ÉÉ„Ç´„Éº</span>
                        </div>
                        <div class="structure-item" data-subtype="vending">
                            <span class="structure-icon vending">V</span>
                            <span>Ëá™Ë≤©Ê©ü</span>
                        </div>
                        <div class="structure-item" data-subtype="shelf">
                            <span class="structure-icon shelf">Ê£ö</span>
                            <span>Ê£ö</span>
                        </div>
                        <div class="structure-item" data-subtype="pillar">
                            <span class="structure-icon pillar">Êü±</span>
                            <span>Êü±</span>
                        </div>
                        <div class="structure-item" data-subtype="label">
                            <span class="structure-icon label">T</span>
                            <span>„É©„Éô„É´</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- „Ç∞„É™„ÉÉ„Éâ„Ç≥„É≥„ÉÜ„Éä -->
            <div class="grid-container" id="gridContainer">
                <div class="editor-grid" id="editorGrid">
                    <!-- „Ç∞„É™„ÉÉ„Éâ„ÅØJS„ÅßÁîüÊàê -->
                </div>
            </div>
            
            <!-- „Éó„É≠„Éë„ÉÜ„Ç£„Éë„Éç„É´ -->
            <div class="property-panel">
                <div class="panel-section">
                    <div class="panel-title">ÈÅ∏Êäû‰∏≠</div>
                    <div class="property-content" id="propertyContent">
                        <div style="color: var(--text-secondary); font-size: 12px;">
                            „Çª„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- „Çπ„ÉÜ„Éº„Çø„Çπ„Éê„Éº -->
        <div class="status-bar">
            <div class="status-info">
                <span id="statusHole">Â∫óËàó: Êú™ÈÅ∏Êäû</span>
                <span id="statusGrid">„Ç∞„É™„ÉÉ„Éâ: -</span>
                <span id="statusCells">„Çª„É´Êï∞: -</span>
                <span id="statusSource">„ÇΩ„Éº„Çπ: -</span>
            </div>
            <div id="statusMessage">„É¨„Ç§„Ç¢„Ç¶„Éà„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ</div>
        </div>
    </div>
    
    <!-- Âè∞Áï™Âè∑ÂÖ•Âäõ„É¢„Éº„ÉÄ„É´ -->
    <div id="machineModal" class="modal-overlay">
        <div class="modal">
            <h3>Âè∞Áï™Âè∑„ÇíÂÖ•Âäõ</h3>
            <input type="number" id="machineNumberInput" class="property-input" placeholder="‰æã: 1205">
            <div class="modal-buttons">
                <button class="modal-btn secondary" id="machineModalCancel">„Ç≠„É£„É≥„Çª„É´</button>
                <button class="modal-btn primary" id="machineModalOk">ËøΩÂä†</button>
            </div>
        </div>
    </div>
    
    <!-- „É©„Éô„É´ÂÖ•Âäõ„É¢„Éº„ÉÄ„É´ -->
    <div id="labelModal" class="modal-overlay">
        <div class="modal">
            <h3 id="labelModalTitle">„É©„Éô„É´„ÇíÂÖ•Âäõ</h3>
            <input type="text" id="labelInput" class="property-input" placeholder="‰æã: POS">
            <div class="modal-buttons">
                <button class="modal-btn secondary" id="labelModalCancel">„Ç≠„É£„É≥„Çª„É´</button>
                <button class="modal-btn primary" id="labelModalOk">ËøΩÂä†</button>
            </div>
        </div>
    </div>
    
    <!-- „Ç∞„É™„ÉÉ„ÉâË®≠ÂÆö„É¢„Éº„ÉÄ„É´ -->
    <div id="gridModal" class="modal-overlay">
        <div class="modal">
            <h3>„Ç∞„É™„ÉÉ„ÉâË®≠ÂÆö</h3>
            <div class="property-row">
                <label class="property-label">Ë°åÊï∞</label>
                <input type="number" id="gridRowsInput" class="property-input" min="1" max="200">
            </div>
            <div class="property-row">
                <label class="property-label">ÂàóÊï∞</label>
                <input type="number" id="gridColsInput" class="property-input" min="1" max="200">
            </div>
            <div class="property-row" style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-color);">
                <label class="property-label">Ë°å„ÅÆÊã°ÂºµÊñπÂêë</label>
                <div style="display: flex; gap: 12px;">
                    <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                        <input type="radio" name="rowExpand" value="bottom" checked> ‰∏ã„Å∏
                    </label>
                    <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                        <input type="radio" name="rowExpand" value="top"> ‰∏ä„Å∏
                    </label>
                </div>
            </div>
            <div class="property-row">
                <label class="property-label">Âàó„ÅÆÊã°ÂºµÊñπÂêë</label>
                <div style="display: flex; gap: 12px;">
                    <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                        <input type="radio" name="colExpand" value="right" checked> Âè≥„Å∏
                    </label>
                    <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                        <input type="radio" name="colExpand" value="left"> Â∑¶„Å∏
                    </label>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="modal-btn secondary" id="gridModalCancel">„Ç≠„É£„É≥„Çª„É´</button>
                <button class="modal-btn primary" id="gridModalOk">ÈÅ©Áî®</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπË®àÊ∏¨Âü∫Áõ§Ôºà?perf=true „ÅßÊúâÂäπÂåñÔºâ
        // ============================================================================
        const PERF_ENABLED = new URLSearchParams(window.location.search).has('perf');

        const PerfLogger = {
            enabled: PERF_ENABLED,
            metrics: [],
            
            measure(label, fn) {
                if (!this.enabled) return fn();
                const start = performance.now();
                const result = fn();
                const duration = performance.now() - start;
                this.log(label, duration);
                return result;
            },
            
            async measureAsync(label, fn) {
                if (!this.enabled) return fn();
                const start = performance.now();
                const result = await fn();
                const duration = performance.now() - start;
                this.log(label, duration);
                return result;
            },
            
            log(label, duration) {
                const entry = { label, duration, timestamp: Date.now() };
                this.metrics.push(entry);
                // „É°„É¢„É™‰∏äÈôê: ÊúÄÊñ∞1000‰ª∂„ÅÆ„Åø‰øùÊåÅ
                if (this.metrics.length > 1000) this.metrics.shift();
                if (duration > 16) {
                    console.warn(`[PERF] ${label}: ${duration.toFixed(1)}ms (> 16ms frame budget)`);
                } else if (duration > 4) {
                    console.log(`[PERF] ${label}: ${duration.toFixed(1)}ms`);
                } else {
                    console.debug(`[PERF] ${label}: ${duration.toFixed(1)}ms`);
                }
            },
            
            report() {
                const grouped = {};
                this.metrics.forEach(m => {
                    if (!grouped[m.label]) {
                        grouped[m.label] = { count: 0, total: 0, max: 0, min: Infinity };
                    }
                    const g = grouped[m.label];
                    g.count++;
                    g.total += m.duration;
                    g.max = Math.max(g.max, m.duration);
                    g.min = Math.min(g.min, m.duration);
                });
                const rows = Object.entries(grouped).map(([label, g]) => ({
                    label,
                    count: g.count,
                    avg: (g.total / g.count).toFixed(1) + 'ms',
                    max: g.max.toFixed(1) + 'ms',
                    min: g.min.toFixed(1) + 'ms',
                    total: g.total.toFixed(1) + 'ms',
                }));
                console.table(rows);
                return rows;
            },
            
            clear() {
                this.metrics = [];
                console.log('[PERF] Metrics cleared');
            }
        };

        const FPSMonitor = {
            frames: 0,
            lastTime: performance.now(),
            display: null,
            running: false,
            
            start() {
                this.display = document.getElementById('fpsCounter');
                if (this.display) this.display.style.display = '';
                this.running = true;
                this.tick();
            },
            stop() {
                this.running = false;
                if (this.display) this.display.style.display = 'none';
            },
            tick() {
                if (!this.running) return;
                this.frames++;
                const now = performance.now();
                if (now - this.lastTime >= 1000) {
                    const fps = Math.round(this.frames * 1000 / (now - this.lastTime));
                    if (this.display) {
                        this.display.textContent = `${fps} FPS`;
                        this.display.style.color = fps >= 50 ? 'var(--accent-green)' : fps >= 30 ? 'var(--accent-yellow)' : 'var(--accent-red)';
                    }
                    this.frames = 0;
                    this.lastTime = now;
                }
                requestAnimationFrame(() => this.tick());
            }
        };

        // Long Task Ê§úÁü•Ôºà50msË∂Ö„ÅÆ„Çø„Çπ„ÇØ„ÇíËá™Âãï„É≠„Ç∞Ôºâ
        if (PERF_ENABLED && typeof PerformanceObserver !== 'undefined') {
            try {
                new PerformanceObserver(list => {
                    list.getEntries().forEach(entry => {
                        console.warn(`[PERF] Long Task detected: ${entry.duration.toFixed(1)}ms`);
                    });
                }).observe({ entryTypes: ['longtask'] });
            } catch (e) { /* longtask not supported */ }
        }

        // „Éá„Éê„ÉÉ„Ç∞Áî®„Ç∞„É≠„Éº„Éê„É´ÂÖ¨Èñã
        if (PERF_ENABLED) {
            window.PerfLogger = PerfLogger;
            window.FPSMonitor = FPSMonitor;
        }

        // ============================================================================
        // Áä∂ÊÖãÁÆ°ÁêÜ
        // ============================================================================
        let layoutData = null;
        let selectedObjectType = 'machine'; // machine, escalator, stairs, counter, locker, vending, shelf, pillar, label
        let selectedCells = new Set();
        let undoStack = [];
        let redoStack = [];
        let isDirty = false;
        let layoutSource = null;
        
        // „Éâ„É©„ÉÉ„Ç∞Èñ¢ÈÄ£
        let isDragging = false;
        let dragStartCell = null;
        let draggedCells = [];
        
        // ÁØÑÂõ≤ÈÅ∏ÊäûÈñ¢ÈÄ£
        let isRangeSelecting = false;
        let rangeSelectStart = null;
        let rangeSelectEnd = null;
        
        // „Çª„É´Ë¶ÅÁ¥†„Ç≠„É£„ÉÉ„Ç∑„É•ÔºàquerySelector„ÇíÈÅø„Åë„Çã„Åü„ÇÅÔºâ
        let cellElementCache = new Map(); // key: "row-col", value: DOM element
        
        // Á©∫Èñì„Ç§„É≥„Éá„ÉÉ„ÇØ„ÇπÔºà„Çª„É´„Éá„Éº„Çø„ÅÆ O(1) Ê§úÁ¥¢Áî®Ôºâ
        let cellSpatialIndex = new Map(); // key: "row-col" -> cellData
        let mergedCellsIndex = new Set(); // „Éû„Éº„Ç∏„Åï„Çå„ÅüÂ≠ê„Çª„É´„ÅÆ‰ΩçÁΩÆÔºàkey: "row-col"Ôºâ
        
        // „Ç∫„Éº„É†„Éª„Éë„É≥Èñ¢ÈÄ£
        let zoomLevel = 1;
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;
        let lastPanX = 0;
        let lastPanY = 0;
        
        // „Çø„ÉÉ„ÉÅÈñ¢ÈÄ£Ôºà„Éî„É≥„ÉÅ„Ç∫„Éº„É†Áî®Ôºâ
        let initialPinchDistance = 0;
        let initialZoom = 1;
        
        // ============================================================================
        // ÂàùÊúüÂåñ
        // ============================================================================
        
        async function init() {
            // „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„É¢„Éã„Çø„ÉºËµ∑Âãï
            if (PERF_ENABLED) {
                FPSMonitor.start();
                console.log('[PERF] Performance monitoring enabled. Use PerfLogger.report() to view stats.');
            }
            
            // Â∫óËàó‰∏ÄË¶ß„ÇíÂèñÂæó
            await loadHoleList();
            
            // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
            setupEventListeners();
            
            // „Ç∫„Éº„É†„Éª„Éë„É≥Ê©üËÉΩ
            setupZoomPan();
        }
        
        // ============================================================================
        // Á©∫Èñì„Ç§„É≥„Éá„ÉÉ„ÇØ„ÇπÁÆ°ÁêÜ
        // ============================================================================
        
        function rebuildSpatialIndex() {
            cellSpatialIndex.clear();
            mergedCellsIndex.clear();
            if (!layoutData) return;
            
            layoutData.cells.forEach(cell => {
                cellSpatialIndex.set(`${cell.row}-${cell.col}`, cell);
                if (cell.mergeRows > 1 || cell.mergeCols > 1) {
                    const mr = cell.mergeRows || 1;
                    const mc = cell.mergeCols || 1;
                    for (let r = 0; r < mr; r++) {
                        for (let c = 0; c < mc; c++) {
                            if (r !== 0 || c !== 0) {
                                mergedCellsIndex.add(`${cell.row + r}-${cell.col + c}`);
                            }
                        }
                    }
                }
            });
        }
        
        function addCellToIndex(cell) {
            cellSpatialIndex.set(`${cell.row}-${cell.col}`, cell);
            if (cell.mergeRows > 1 || cell.mergeCols > 1) {
                const mr = cell.mergeRows || 1;
                const mc = cell.mergeCols || 1;
                for (let r = 0; r < mr; r++) {
                    for (let c = 0; c < mc; c++) {
                        if (r !== 0 || c !== 0) {
                            mergedCellsIndex.add(`${cell.row + r}-${cell.col + c}`);
                        }
                    }
                }
            }
        }
        
        function removeCellFromIndex(cell) {
            cellSpatialIndex.delete(`${cell.row}-${cell.col}`);
            if (cell.mergeRows > 1 || cell.mergeCols > 1) {
                const mr = cell.mergeRows || 1;
                const mc = cell.mergeCols || 1;
                for (let r = 0; r < mr; r++) {
                    for (let c = 0; c < mc; c++) {
                        if (r !== 0 || c !== 0) {
                            mergedCellsIndex.delete(`${cell.row + r}-${cell.col + c}`);
                        }
                    }
                }
            }
        }
        
        async function loadHoleList() {
            try {
                const response = await fetch('/api/heatmap/layouts');
                const data = await response.json();
                
                const select = document.getElementById('holeSelect');
                data.layouts.forEach(layout => {
                    const option = document.createElement('option');
                    option.value = layout.hole;
                    option.textContent = `${layout.hole} (${layout.source || 'local'})`;
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Â∫óËàó‰∏ÄË¶ßÂèñÂæó„Ç®„É©„Éº:', error);
            }
        }
        
        function setupEventListeners() {
            // Ë™≠„ÅøËæº„Åø„Éú„Çø„É≥
            document.getElementById('loadBtn').addEventListener('click', loadLayout);
            
            // ‰øùÂ≠ò„Éú„Çø„É≥
            document.getElementById('saveBtn').addEventListener('click', saveLayout);
            
            // „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çø„Ç§„ÉóÈÅ∏Êäû
            document.querySelectorAll('.structure-item').forEach(item => {
                item.addEventListener('click', () => selectObjectType(item.dataset.subtype));
            });
            
            // „Ç∫„Éº„É†„Ç≥„É≥„Éà„É≠„Éº„É´
            document.getElementById('zoomInBtn').addEventListener('click', zoomIn);
            document.getElementById('zoomOutBtn').addEventListener('click', zoomOut);
            document.getElementById('zoomResetBtn').addEventListener('click', resetZoom);
            
            // Undo/Redo
            document.getElementById('undoBtn').addEventListener('click', undo);
            document.getElementById('redoBtn').addEventListener('click', redo);
            
            // „Ç∞„É™„ÉÉ„ÉâË®≠ÂÆö
            document.getElementById('gridSettingsBtn').addEventListener('click', showGridSettings);
            document.getElementById('gridModalCancel').addEventListener('click', () => closeModal('gridModal'));
            document.getElementById('gridModalOk').addEventListener('click', applyGridSettings);
            
            // Âè∞Áï™Âè∑„É¢„Éº„ÉÄ„É´
            document.getElementById('machineModalCancel').addEventListener('click', () => closeModal('machineModal'));
            document.getElementById('machineModalOk').addEventListener('click', addMachineFromModal);
            document.getElementById('machineNumberInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addMachineFromModal();
            });
            
            // „É©„Éô„É´„É¢„Éº„ÉÄ„É´
            document.getElementById('labelModalCancel').addEventListener('click', () => closeModal('labelModal'));
            document.getElementById('labelModalOk').addEventListener('click', addLabelFromModal);
            document.getElementById('labelInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addLabelFromModal();
            });
            
            // „Ç≠„Éº„Éú„Éº„Éâ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà
            document.addEventListener('keydown', handleKeydown);
            
            // „Ç∞„É™„ÉÉ„Éâ„ÅÆ„Ç§„Éô„É≥„ÉàÂßîË≠≤Ôºà„Çª„É´„Åî„Å®„Å´„É™„Çπ„Éä„Éº„ÇíËøΩÂä†„Åô„Çã‰ª£„Çè„Çä„Å´„ÄÅ„Ç∞„É™„ÉÉ„Éâ„Å´1„Å§„Å†„ÅëËøΩÂä†Ôºâ
            const grid = document.getElementById('editorGrid');
            grid.addEventListener('click', (e) => {
                const cell = e.target.closest('.editor-cell');
                if (!cell) return;
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                handleCellClick(e, row, col);
            });
            grid.addEventListener('mousedown', (e) => {
                const cell = e.target.closest('.editor-cell');
                if (!cell) return;
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                handleCellMouseDown(e, row, col);
            });
            grid.addEventListener('mouseenter', (e) => {
                const cell = e.target.closest('.editor-cell');
                if (!cell) return;
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                handleCellMouseEnter(e, row, col);
            }, true); // „Ç≠„É£„Éó„ÉÅ„É£„Éï„Çß„Éº„Ç∫„ÅßÂá¶ÁêÜÔºàÂ≠êË¶ÅÁ¥†„Å∏„ÅÆenter„ÇÇÊ§úÁü•Ôºâ
            grid.addEventListener('mouseup', (e) => {
                const cell = e.target.closest('.editor-cell');
                if (!cell) return;
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                handleCellMouseUp(e, row, col);
            });
            // mouseover „ÅØ mouseenter (capture) „Å®ÈáçË§á„Åô„Çã„Åü„ÇÅÂâäÈô§
        }
        
        // ============================================================================
        // „Ç∫„Éº„É†„Éª„Éë„É≥Ê©üËÉΩ
        // ============================================================================
        
        // „Çπ„Éö„Éº„Çπ„Ç≠„ÉºÊäº‰∏ãÁä∂ÊÖã
        let isSpacePressed = false;
        
        function setupZoomPan() {
            const container = document.getElementById('gridContainer');
            const grid = document.getElementById('editorGrid');
            
            // „Éõ„Ç§„Éº„É´„Åß„Ç∫„Éº„É†Ôºà„Çπ„ÇØ„É≠„Éº„É´ÁÑ°ÂäπÂåñÔºâ
            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -0.1 : 0.1;
                const newZoom = Math.max(0.2, Math.min(3, zoomLevel + delta));
                
                // „Éû„Ç¶„Çπ‰ΩçÁΩÆ„Çí‰∏≠ÂøÉ„Å´„Ç∫„Éº„É†
                const rect = container.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // „Ç∫„Éº„É†Ââç„ÅÆ„Éû„Ç¶„Çπ‰ΩçÁΩÆÔºà„Ç∞„É™„ÉÉ„ÉâÂ∫ßÊ®ôÔºâ
                const gridX = (mouseX - panX) / zoomLevel;
                const gridY = (mouseY - panY) / zoomLevel;
                
                zoomLevel = newZoom;
                
                // „Ç∫„Éº„É†Âæå„ÅÆ„Éû„Ç¶„Çπ‰ΩçÁΩÆ„Çí‰øùÊåÅ„Åô„Çã„Çà„ÅÜ„Å´„Éë„É≥Ë™øÊï¥
                panX = mouseX - gridX * zoomLevel;
                panY = mouseY - gridY * zoomLevel;
                
                applyZoomPan();
            }, { passive: false });
            
            // „Çπ„Éö„Éº„Çπ„Ç≠„Éº„Åß„Éë„É≥„É¢„Éº„ÉâÔºà„É¢„Éº„ÉÄ„É´„ÅåÈñã„ÅÑ„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅÆ„ÅøÔºâ
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space' && !isSpacePressed && !document.querySelector('.modal-overlay.active')) {
                    e.preventDefault();
                    isSpacePressed = true;
                    container.style.cursor = 'grab';
                }
            });
            
            document.addEventListener('keyup', (e) => {
                if (e.code === 'Space') {
                    isSpacePressed = false;
                    if (!isPanning) {
                        container.style.cursor = '';
                    }
                }
            });
            
            // „Çπ„Éö„Éº„Çπ+Â∑¶„ÇØ„É™„ÉÉ„ÇØ „Åæ„Åü„ÅØ ‰∏≠„Éú„Çø„É≥„Åß„Éë„É≥
            container.addEventListener('mousedown', (e) => {
                if (e.button === 1 || (e.button === 0 && isSpacePressed)) {
                    e.preventDefault();
                    isPanning = true;
                    panStartX = e.clientX;
                    panStartY = e.clientY;
                    lastPanX = panX;
                    lastPanY = panY;
                    container.style.cursor = 'grabbing';
                }
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isPanning) {
                    panX = lastPanX + (e.clientX - panStartX);
                    panY = lastPanY + (e.clientY - panStartY);
                    applyZoomPan();
                }
            });
            
            document.addEventListener('mouseup', () => {
                if (isPanning) {
                    isPanning = false;
                    document.getElementById('gridContainer').style.cursor = isSpacePressed ? 'grab' : '';
                }
            });
            
            // „Çø„ÉÉ„ÉÅÊìç‰ΩúÔºà„Éî„É≥„ÉÅ„Ç∫„Éº„É†„ÄÅ2Êú¨Êåá„Éë„É≥Ôºâ
            container.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    initialPinchDistance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );
                    initialZoom = zoomLevel;
                    
                    // „Éë„É≥„ÅÆÈñãÂßã‰ΩçÁΩÆ
                    const centerX = (touch1.clientX + touch2.clientX) / 2;
                    const centerY = (touch1.clientY + touch2.clientY) / 2;
                    panStartX = centerX;
                    panStartY = centerY;
                    lastPanX = panX;
                    lastPanY = panY;
                }
            }, { passive: false });
            
            container.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    
                    // „Éî„É≥„ÉÅ„Ç∫„Éº„É†
                    const currentDistance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );
                    const scale = currentDistance / initialPinchDistance;
                    zoomLevel = Math.max(0.2, Math.min(3, initialZoom * scale));
                    
                    // 2Êú¨Êåá„Éë„É≥
                    const centerX = (touch1.clientX + touch2.clientX) / 2;
                    const centerY = (touch1.clientY + touch2.clientY) / 2;
                    panX = lastPanX + (centerX - panStartX);
                    panY = lastPanY + (centerY - panStartY);
                    
                    applyZoomPan();
                }
            }, { passive: false });
        }
        
        let zoomPanPending = false;
        
        function applyZoomPan() {
            if (zoomPanPending) return;
            zoomPanPending = true;
            requestAnimationFrame(() => {
                zoomPanPending = false;
                applyZoomPanImmediate();
            });
        }
        
        function applyZoomPanImmediate() {
            const container = document.getElementById('gridContainer');
            const grid = document.getElementById('editorGrid');
            
            // „Éë„É≥ÁØÑÂõ≤„ÇíÂà∂ÈôêÔºà„Ç∞„É™„ÉÉ„Éâ„ÅÆ20%„ÅØÂ∏∏„Å´Ë¶ã„Åà„Çã„Çà„ÅÜ„Å´Ôºâ
            const containerRect = container.getBoundingClientRect();
            const gridWidth = grid.offsetWidth * zoomLevel;
            const gridHeight = grid.offsetHeight * zoomLevel;
            const margin = 50; // ÊúÄ‰ΩéÈôêË¶ã„Åà„ÇãÁØÑÂõ≤ÔºàpxÔºâ
            
            const minX = containerRect.width - gridWidth - margin;
            const maxX = margin;
            const minY = containerRect.height - gridHeight - margin;
            const maxY = margin;
            
            panX = Math.max(minX, Math.min(maxX, panX));
            panY = Math.max(minY, Math.min(maxY, panY));
            
            grid.style.transform = `translate(${panX}px, ${panY}px) scale(${zoomLevel})`;
            grid.style.transformOrigin = '0 0';
            updateZoomDisplay();
        }
        
        function updateZoomDisplay() {
            const zoomDisplay = document.getElementById('zoomLevel');
            if (zoomDisplay) {
                zoomDisplay.textContent = `${Math.round(zoomLevel * 100)}%`;
            }
        }
        
        function zoomIn() {
            zoomLevel = Math.min(3, zoomLevel + 0.2);
            applyZoomPan();
        }
        
        function zoomOut() {
            zoomLevel = Math.max(0.2, zoomLevel - 0.2);
            applyZoomPan();
        }
        
        function resetZoom() {
            zoomLevel = 1;
            panX = 0;
            panY = 0;
            applyZoomPan();
        }
        
        // ============================================================================
        // „É¨„Ç§„Ç¢„Ç¶„ÉàË™≠„ÅøËæº„Åø/‰øùÂ≠ò
        // ============================================================================
        
        async function loadLayout() {
            const hole = document.getElementById('holeSelect').value;
            if (!hole) {
                alert('Â∫óËàó„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
                return;
            }
            
            try {
                const response = await fetch(`/api/heatmap/layouts/${encodeURIComponent(hole)}`);
                if (!response.ok) throw new Error('„É¨„Ç§„Ç¢„Ç¶„Éà„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
                
                layoutData = await response.json();
                layoutSource = response.headers.get('X-Layout-Source') || 'unknown';
                
                // Áä∂ÊÖã„É™„Çª„ÉÉ„Éà
                selectedCells.clear();
                undoStack = [];
                redoStack = [];
                isDirty = false;
                
                rebuildSpatialIndex();
                renderGrid();
                updateStatus();
                setMessage(`„É¨„Ç§„Ç¢„Ç¶„Éà„ÇíË™≠„ÅøËæº„Åø„Åæ„Åó„ÅüÔºà${layoutSource}Ôºâ`);
            } catch (error) {
                console.error('Ë™≠„ÅøËæº„Åø„Ç®„É©„Éº:', error);
                alert('„É¨„Ç§„Ç¢„Ç¶„Éà„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + error.message);
            }
        }
        
        async function saveLayout() {
            if (!layoutData) {
                alert('„É¨„Ç§„Ç¢„Ç¶„Éà„ÅåË™≠„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì');
                return;
            }
            
            try {
                const response = await fetch(`/api/heatmap/layouts/${encodeURIComponent(layoutData.hole)}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(layoutData),
                });
                
                if (!response.ok) throw new Error('‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
                
                const result = await response.json();
                isDirty = false;
                layoutSource = 'gcs';
                updateStatus();
                setMessage(`‰øùÂ≠ò„Åó„Åæ„Åó„ÅüÔºà${result.cellCount}„Çª„É´Ôºâ`);
            } catch (error) {
                console.error('‰øùÂ≠ò„Ç®„É©„Éº:', error);
                alert('‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + error.message);
            }
        }
        
        // ============================================================================
        // „Ç∞„É™„ÉÉ„ÉâÊèèÁîª
        // ============================================================================
        
        function renderGrid() {
            PerfLogger.measure('renderGrid', () => {
                const grid = document.getElementById('editorGrid');
                grid.innerHTML = '';
                cellElementCache.clear();
                
                if (!layoutData) return;
                
                // Á©∫Èñì„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÇíÂÜçÊßãÁØâÔºàundo/redoÁ≠â„ÅßlayoutDataËá™‰Ωì„ÅåÁΩÆ„ÅçÊèõ„Çè„ÇãÂ†¥ÂêàÔºâ
                rebuildSpatialIndex();
                
                const { rows, cols } = layoutData.grid;
                grid.style.gridTemplateColumns = `repeat(${cols}, var(--cell-size))`;
                grid.style.gridTemplateRows = `repeat(${rows}, var(--cell-size))`;
                
                // DocumentFragment„Åß‰∏ÄÊã¨ËøΩÂä†ÔºàDOMÊìç‰ΩúÂõûÊï∞„ÇíÂâäÊ∏õÔºâ
                const fragment = document.createDocumentFragment();
                
                // „Ç∞„É™„ÉÉ„Éâ„ÇíÁîüÊàê
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const key = `${row}-${col}`;
                        const cellData = cellSpatialIndex.get(key);
                        
                        // „Éû„Éº„Ç∏„Åï„Çå„ÅüÂ≠ê„Çª„É´„ÅØ„Çπ„Ç≠„ÉÉ„ÉóÔºàË¶™„Çª„É´„Ååspan„ÅßË¶Ü„ÅÜÔºâ
                        if (mergedCellsIndex.has(key)) {
                            continue;
                        }
                        
                        const cellElement = document.createElement('div');
                        cellElement.className = 'editor-cell';
                        cellElement.dataset.row = row;
                        cellElement.dataset.col = col;
                        
                        if (cellData) {
                            renderCellContent(cellElement, cellData);
                            
                            // „Éû„Éº„Ç∏„Åï„Çå„Åü„Çª„É´ÔºàË¶™Ôºâ„ÅØÂ§ß„Åç„ÅèË°®Á§∫
                            if (cellData.mergeRows > 1 || cellData.mergeCols > 1) {
                                const mr = cellData.mergeRows || 1;
                                const mc = cellData.mergeCols || 1;
                                cellElement.style.gridRow = `${row + 1} / span ${mr}`;
                                cellElement.style.gridColumn = `${col + 1} / span ${mc}`;
                                cellElement.classList.add('merged-parent');
                            } else {
                                cellElement.style.gridRow = String(row + 1);
                                cellElement.style.gridColumn = String(col + 1);
                            }
                        } else {
                            cellElement.style.gridRow = String(row + 1);
                            cellElement.style.gridColumn = String(col + 1);
                        }
                        
                        // ÈÅ∏ÊäûÁä∂ÊÖã
                        if (selectedCells.has(key)) {
                            cellElement.classList.add('selected');
                        }
                        
                        fragment.appendChild(cellElement);
                        cellElementCache.set(key, cellElement);
                    }
                }
                
                grid.appendChild(fragment);
            });
        }
        
        // Â§âÊõ¥„Åï„Çå„Åü„Çª„É´„ÅÆ„ÅøDOM„ÇíÊõ¥Êñ∞Ôºà„Ç§„É≥„ÇØ„É™„É°„É≥„Çø„É´Êõ¥Êñ∞Ôºâ
        function updateCells(changedKeys) {
            PerfLogger.measure('updateCells', () => {
                changedKeys.forEach(key => {
                    const el = cellElementCache.get(key);
                    if (!el) return;
                    
                    const cellData = cellSpatialIndex.get(key);
                    
                    // „ÇØ„É©„Çπ„Çí„É™„Çª„ÉÉ„ÉàÔºàselected „ÅØÂà•ÈÄîÁÆ°ÁêÜÔºâ
                    const isSelected = selectedCells.has(key);
                    el.className = 'editor-cell';
                    el.textContent = '';
                    
                    if (cellData) {
                        renderCellContent(el, cellData);
                    }
                    
                    if (isSelected) {
                        el.classList.add('selected');
                    }
                });
            });
        }
        
        // ÈÅ∏ÊäûÁä∂ÊÖã„ÅÆÂ∑ÆÂàÜÊõ¥Êñ∞ÔºàclassList „ÅÆ„ÅøÊìç‰ΩúÔºâ
        function updateSelection(oldSelected, newSelected) {
            PerfLogger.measure('updateSelection', () => {
                oldSelected.forEach(key => {
                    if (!newSelected.has(key)) {
                        const el = cellElementCache.get(key);
                        if (el) el.classList.remove('selected');
                    }
                });
                newSelected.forEach(key => {
                    if (!oldSelected.has(key)) {
                        const el = cellElementCache.get(key);
                        if (el) el.classList.add('selected');
                    }
                });
            });
        }
        
        // „Ç≠„É£„ÉÉ„Ç∑„É•„Åã„Çâ„Çª„É´Ë¶ÅÁ¥†„ÇíÂèñÂæóÔºàquerySelector„ÅÆ‰ª£„Çè„ÇäÔºâ
        function getCellElement(row, col) {
            return cellElementCache.get(`${row}-${col}`);
        }
        
        function renderCellContent(element, cellData) {
            const { type, subtype, number, text, label } = cellData;
            
            if (type === 'machine') {
                element.classList.add('machine');
                element.textContent = number;
            } else if (type === 'structure') {
                element.classList.add('structure', subtype || '');
                element.textContent = label || '';
            } else if (type === 'label') {
                element.classList.add('label');
                element.textContent = text || '';
            }
        }
        
        // ============================================================================
        // „ÉÑ„Éº„É´Êìç‰Ωú
        // ============================================================================
        
        function selectObjectType(subtype) {
            selectedObjectType = subtype;
            document.querySelectorAll('.structure-item').forEach(item => {
                item.classList.toggle('selected', item.dataset.subtype === subtype);
            });
        }
        
        // ============================================================================
        // „Çª„É´„ÇØ„É™„ÉÉ„ÇØÂá¶ÁêÜ
        // ============================================================================
        
        function handleCellClick(e, row, col) {
            const key = `${row}-${col}`;
            const oldSelected = new Set(selectedCells);
            
            // „ÇØ„É™„ÉÉ„ÇØ„ÅßÈÅ∏ÊäûÔºàÁ©∫„Åß„ÇÇÊó¢Â≠ò„Åß„ÇÇÔºâ
            if (e.shiftKey) {
                // Shift+„ÇØ„É™„ÉÉ„ÇØ„ÅßË§áÊï∞ÈÅ∏Êäû
                if (selectedCells.has(key)) {
                    selectedCells.delete(key);
                } else {
                    selectedCells.add(key);
                }
            } else {
                // Âçò‰∏ÄÈÅ∏Êäû
                selectedCells.clear();
                selectedCells.add(key);
            }
            updateSelection(oldSelected, selectedCells);
            updatePropertyPanel();
        }
        
        // ÈÅ∏Êäû„Åó„Åü„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çø„Ç§„Éó„Çí„Çª„É´„Å´ÈÖçÁΩÆ
        function placeObjectAtCell(row, col) {
            const key = `${row}-${col}`;
            const existingCell = cellSpatialIndex.get(key);
            
            // Êó¢Â≠ò„ÅÆ„Çª„É´„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ‰∏äÊõ∏„ÅçÁ¢∫Ë™ç
            if (existingCell) {
                if (existingCell.type === 'machine') {
                    alert('„Åì„ÅÆ„Çª„É´„Å´„ÅØÂè∞„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇÂè≥„Éë„Éç„É´„Åã„ÇâÂâäÈô§„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
                    return;
                }
                // ÊßãÈÄ†Áâ©„ÇÑ„É©„Éô„É´„ÅØ‰∏äÊõ∏„Åç
                saveState();
                removeCellFromIndex(existingCell);
                const index = layoutData.cells.indexOf(existingCell);
                if (index >= 0) layoutData.cells.splice(index, 1);
            } else {
                saveState();
            }
            
            if (selectedObjectType === 'machine') {
                // Âè∞„ÅÆÂ†¥Âêà„ÅØ„É¢„Éº„ÉÄ„É´„ÅßÁï™Âè∑ÂÖ•Âäõ
                pendingCellPosition = { row, col };
                document.getElementById('machineNumberInput').value = '';
                openModal('machineModal');
                document.getElementById('machineNumberInput').focus();
            } else if (selectedObjectType === 'label') {
                // „É©„Éô„É´„ÅÆÂ†¥Âêà„ÅØ„É¢„Éº„ÉÄ„É´„ÅßÂÖ•Âäõ
                pendingCellPosition = { row, col };
                document.getElementById('labelInput').value = '';
                document.getElementById('labelModalTitle').textContent = '„É©„Éô„É´„ÇíÂÖ•Âäõ';
                openModal('labelModal');
                document.getElementById('labelInput').focus();
            } else {
                // ÊßãÈÄ†Áâ©„ÇíËøΩÂä†Ôºà„É©„Éô„É´ÂÖ•Âäõ„Å™„ÅóÔºâ
                const newCell = {
                    row, col,
                    type: 'structure',
                    subtype: selectedObjectType,
                };
                layoutData.cells.push(newCell);
                addCellToIndex(newCell);
                markDirty();
                updateCells([key]);
            }
        }
        
        // ÁØÑÂõ≤„Å´ÊßãÈÄ†Áâ©„ÇíÈÖçÁΩÆ
        // ÁØÑÂõ≤ÈÅ∏Êäû„Åß„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÈÖçÁΩÆ
        function placeObjectInRange() {
            if (selectedCells.size < 1) return;
            
            // Âè∞„ÅØÁØÑÂõ≤ÈÖçÁΩÆ„Åß„Åç„Å™„ÅÑ
            if (selectedObjectType === 'machine') {
                alert('Âè∞„ÅØ1„Å§„Åö„Å§ÈÖçÁΩÆ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
                return;
            }
            
            // ÈÅ∏ÊäûÁØÑÂõ≤„ÅÆÂ¢ÉÁïå„ÇíË®àÁÆó
            let minRow = Infinity, maxRow = -Infinity;
            let minCol = Infinity, maxCol = -Infinity;
            
            selectedCells.forEach(key => {
                const [row, col] = key.split('-').map(Number);
                minRow = Math.min(minRow, row);
                maxRow = Math.max(maxRow, row);
                minCol = Math.min(minCol, col);
                maxCol = Math.max(maxCol, col);
            });
            
            // ÁØÑÂõ≤ÂÜÖ„Å´Âè∞„Åå„ÅÇ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            let hasMachine = false;
            for (let r = minRow; r <= maxRow; r++) {
                for (let c = minCol; c <= maxCol; c++) {
                    const cell = cellSpatialIndex.get(`${r}-${c}`);
                    if (cell && cell.type === 'machine') {
                        hasMachine = true;
                        break;
                    }
                }
                if (hasMachine) break;
            }
            
            if (hasMachine) {
                alert('ÈÅ∏ÊäûÁØÑÂõ≤ÂÜÖ„Å´Âè∞„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇÂÖà„Å´ÂâäÈô§„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
                return;
            }
            
            // „É©„Éô„É´ÂÖ•Âäõ„ÇíÊ±Ç„ÇÅ„ÇãÔºàÁèæÂú®ÈÅ∏Êäû‰∏≠„ÅÆ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çø„Ç§„Éó„Çí‰ΩøÁî®Ôºâ
            pendingRangeSelection = { minRow, maxRow, minCol, maxCol, objectType: selectedObjectType };
            document.getElementById('labelInput').value = '';
            document.getElementById('labelModalTitle').textContent = 
                selectedObjectType === 'label' ? '„É©„Éô„É´„ÇíÂÖ•Âäõ' : `${getObjectTypeName(selectedObjectType)}„ÅÆ„É©„Éô„É´„ÇíÂÖ•ÂäõÔºà‰ªªÊÑèÔºâ`;
            openModal('labelModal');
            document.getElementById('labelInput').focus();
        }
        
        function getObjectTypeName(subtype) {
            const names = {
                machine: 'Âè∞',
                escalator: '„Ç®„Çπ„Ç´„É¨„Éº„Çø„Éº',
                stairs: 'ÈöéÊÆµ',
                counter: '„Ç´„Ç¶„É≥„Çø„Éº',
                locker: '„É≠„ÉÉ„Ç´„Éº',
                vending: 'Ëá™Ë≤©Ê©ü',
                shelf: 'Ê£ö',
                pillar: 'Êü±',
                label: '„É©„Éô„É´',
            };
            return names[subtype] || subtype;
        }
        
        let pendingRangeSelection = null;
        
        
        // ============================================================================
        // „Éâ„É©„ÉÉ„Ç∞&„Éâ„É≠„ÉÉ„Éó
        // ============================================================================
        
        function handleCellMouseDown(e, row, col) {
            const key = `${row}-${col}`;
            const cellData = cellSpatialIndex.get(key);
            
            if (cellData && selectedCells.has(key) && !e.shiftKey) {
                // ÈÅ∏ÊäûÊ∏à„Åø„Çª„É´„Çí„Éâ„É©„ÉÉ„Ç∞ÁßªÂãï
                isDragging = true;
                dragStartCell = { row, col };
                draggedCells = Array.from(selectedCells).map(k => {
                    return cellSpatialIndex.get(k);
                }).filter(Boolean);
                e.preventDefault();
            } else {
                // ÁØÑÂõ≤ÈÅ∏ÊäûÈñãÂßã
                isRangeSelecting = true;
                rangeSelectStart = { row, col };
                rangeSelectEnd = { row, col };
                if (!e.shiftKey) {
                    // Ââç„ÅÆÈÅ∏Êäû„ÇíËß£Èô§Ôºà„Ç≠„É£„ÉÉ„Ç∑„É•„Çí‰ΩøÁî®Ôºâ
                    selectedCells.forEach(k => {
                        const el = cellElementCache.get(k);
                        if (el) el.classList.remove('selected');
                    });
                    selectedCells.clear();
                }
                selectedCells.add(key);
                // „ÇØ„É™„ÉÉ„ÇØ„Åó„Åü„Çª„É´„Å†„ÅëÈÅ∏ÊäûÔºà„Ç≠„É£„ÉÉ„Ç∑„É•„Çí‰ΩøÁî®Ôºâ
                const clickedEl = cellElementCache.get(key);
                if (clickedEl) clickedEl.classList.add('selected');
                e.preventDefault();
            }
        }
        
        // „Éâ„É©„ÉÉ„Ç∞ÊôÇ„ÅÆ„Éè„Ç§„É©„Ç§„ÉàÂØæË±°„Çª„É´„ÇíËøΩË∑°
        let dragOverCells = new Set();
        
        function handleCellMouseEnter(e, row, col) {
            // ÁØÑÂõ≤ÈÅ∏Êäû‰∏≠
            if (isRangeSelecting) {
                rangeSelectEnd = { row, col };
                updateRangeSelection();
                return;
            }
            
            // „Éâ„É©„ÉÉ„Ç∞ÁßªÂãï‰∏≠
            if (!isDragging) return;
            
            // ÂâçÂõû„ÅÆ„Éâ„É©„ÉÉ„Ç∞„Ç™„Éº„Éê„Éº„ÇíËß£Èô§Ôºà„Ç≠„É£„ÉÉ„Ç∑„É•„Çí‰ΩøÁî®Ôºâ
            dragOverCells.forEach(key => {
                const el = cellElementCache.get(key);
                if (el) el.classList.remove('drag-over');
            });
            dragOverCells.clear();
            
            // „Éâ„É≠„ÉÉ„ÉóÂÖà„Çí„Éè„Ç§„É©„Ç§„ÉàÔºà„Ç≠„É£„ÉÉ„Ç∑„É•„Çí‰ΩøÁî®Ôºâ
            const offsetRow = row - dragStartCell.row;
            const offsetCol = col - dragStartCell.col;
            
            draggedCells.forEach(cell => {
                const newRow = cell.row + offsetRow;
                const newCol = cell.col + offsetCol;
                const key = `${newRow}-${newCol}`;
                const targetCell = cellElementCache.get(key);
                if (targetCell) {
                    targetCell.classList.add('drag-over');
                    dragOverCells.add(key);
                }
            });
        }
        
        // „Çπ„É≠„ÉÉ„Éà„É™„É≥„Ç∞Áî®
        let rangeSelectionPending = false;
        
        function updateRangeSelection() {
            if (!rangeSelectStart || !rangeSelectEnd) return;
            
            // ÂâçÂõû„ÅÆÊõ¥Êñ∞„Åå„Åæ„Å†Âá¶ÁêÜ‰∏≠„Å™„ÇâÊñ∞„Åó„ÅÑ„É™„ÇØ„Ç®„Çπ„Éà„Çí„Ç≠„É•„Éº„Ç§„É≥„Ç∞
            if (rangeSelectionPending) return;
            rangeSelectionPending = true;
            
            requestAnimationFrame(() => {
                rangeSelectionPending = false;
                if (!rangeSelectStart || !rangeSelectEnd) return;
                
                const minRow = Math.min(rangeSelectStart.row, rangeSelectEnd.row);
                const maxRow = Math.max(rangeSelectStart.row, rangeSelectEnd.row);
                const minCol = Math.min(rangeSelectStart.col, rangeSelectEnd.col);
                const maxCol = Math.max(rangeSelectStart.col, rangeSelectEnd.col);
                
                // Ââç„ÅÆÈÅ∏Êäû„ÇíËß£Èô§Ôºà„Ç≠„É£„ÉÉ„Ç∑„É•„Çí‰ΩøÁî®Ôºâ
                selectedCells.forEach(key => {
                    const el = cellElementCache.get(key);
                    if (el) el.classList.remove('selected');
                });
                
                selectedCells.clear();
                
                // Êñ∞„Åó„ÅÑÈÅ∏Êäû„ÇíËøΩÂä†Ôºà„Ç≠„É£„ÉÉ„Ç∑„É•„Çí‰ΩøÁî®Ôºâ
                for (let r = minRow; r <= maxRow; r++) {
                    for (let c = minCol; c <= maxCol; c++) {
                        const key = `${r}-${c}`;
                        selectedCells.add(key);
                        const el = cellElementCache.get(key);
                        if (el) el.classList.add('selected');
                    }
                }
            });
        }
        
        function handleCellMouseUp(e, row, col) {
            // ÁØÑÂõ≤ÈÅ∏ÊäûÁµÇ‰∫Ü
            if (isRangeSelecting) {
                isRangeSelecting = false;
                rangeSelectStart = null;
                rangeSelectEnd = null;
                
                updatePropertyPanel();
                return;
            }
            
            if (!isDragging) return;
            
            const offsetRow = row - dragStartCell.row;
            const offsetCol = col - dragStartCell.col;
            
            if (offsetRow !== 0 || offsetCol !== 0) {
                // ÁßªÂãïÂÖà„ÅåÊúâÂäπ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                let canMove = true;
                const newPositions = draggedCells.map(cell => ({
                    row: cell.row + offsetRow,
                    col: cell.col + offsetCol,
                }));
                
                newPositions.forEach(pos => {
                    if (pos.row < 0 || pos.row >= layoutData.grid.rows ||
                        pos.col < 0 || pos.col >= layoutData.grid.cols) {
                        canMove = false;
                    }
                    
                    // ÁßªÂãïÂÖà„Å´‰ªñ„ÅÆ„Çª„É´„Åå„ÅÇ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØÔºàËá™ÂàÜËá™Ë∫´„ÅØÈô§„ÅèÔºâ
                    const existingCell = cellSpatialIndex.get(`${pos.row}-${pos.col}`);
                    if (existingCell && !draggedCells.includes(existingCell)) {
                        canMove = false;
                    }
                });
                
                if (canMove) {
                    saveState();
                    const oldKeys = draggedCells.map(cell => `${cell.row}-${cell.col}`);
                    
                    // Á©∫Èñì„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Åã„ÇâÊóß‰ΩçÁΩÆ„ÇíÂâäÈô§
                    draggedCells.forEach(cell => removeCellFromIndex(cell));
                    
                    // „Çª„É´„ÇíÁßªÂãï
                    draggedCells.forEach((cell, i) => {
                        cell.row = newPositions[i].row;
                        cell.col = newPositions[i].col;
                    });
                    
                    // Á©∫Èñì„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Å´Êñ∞‰ΩçÁΩÆ„ÇíËøΩÂä†
                    draggedCells.forEach(cell => addCellToIndex(cell));
                    
                    // ÈÅ∏ÊäûÁä∂ÊÖã„ÇíÊõ¥Êñ∞
                    selectedCells.clear();
                    newPositions.forEach(pos => {
                        selectedCells.add(`${pos.row}-${pos.col}`);
                    });
                    
                    markDirty();
                    
                    // „Éû„Éº„Ç∏„Åï„Çå„Åü„Çª„É´„Åå„ÅÇ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                    const hasMerges = draggedCells.some(c => (c.mergeRows || 1) > 1 || (c.mergeCols || 1) > 1);
                    
                    // „Éâ„É©„ÉÉ„Ç∞„Ç™„Éº„Éê„Éº„ÇíËß£Èô§
                    dragOverCells.forEach(key => {
                        const el = cellElementCache.get(key);
                        if (el) el.classList.remove('drag-over');
                    });
                    dragOverCells.clear();
                    
                    isDragging = false;
                    dragStartCell = null;
                    draggedCells = [];
                    
                    if (hasMerges) {
                        renderGrid(); // „Éû„Éº„Ç∏„Çª„É´„ÅÆÁßªÂãï„ÅØ„Éï„É´„É™„Éì„É´„Éâ
                    } else {
                        const newKeys = newPositions.map(p => `${p.row}-${p.col}`);
                        updateCells([...oldKeys, ...newKeys]);
                    }
                    return;
                }
            }
            
            // „Éâ„É©„ÉÉ„Ç∞ÁµÇ‰∫ÜÔºàÁßªÂãï„Å™„Åó or ÁßªÂãï‰∏çÂèØÔºâ
            isDragging = false;
            dragStartCell = null;
            draggedCells = [];
            
            // „Éâ„É©„ÉÉ„Ç∞„Ç™„Éº„Éê„Éº„ÇíËß£Èô§Ôºà„Ç≠„É£„ÉÉ„Ç∑„É•„Çí‰ΩøÁî®Ôºâ
            dragOverCells.forEach(key => {
                const el = cellElementCache.get(key);
                if (el) el.classList.remove('drag-over');
            });
            dragOverCells.clear();
        }
        
        // „Ç∞„É≠„Éº„Éê„É´„ÅÆmouseupÔºà„Ç∞„É™„ÉÉ„ÉâÂ§ñ„Åß„ÅÆ„Éû„Ç¶„Çπ„Ç¢„ÉÉ„ÉóÂØæÂøúÔºâ
        document.addEventListener('mouseup', () => {
            if (isRangeSelecting) {
                isRangeSelecting = false;
                rangeSelectStart = null;
                rangeSelectEnd = null;
                updatePropertyPanel();
            }
        });
        
        // ============================================================================
        // „É¢„Éº„ÉÄ„É´
        // ============================================================================
        
        let pendingCellPosition = null;
        
        function openModal(id) {
            document.getElementById(id).classList.add('active');
        }
        
        function closeModal(id) {
            document.getElementById(id).classList.remove('active');
            pendingCellPosition = null;
        }
        
        function addMachineFromModal() {
            const numberInput = document.getElementById('machineNumberInput');
            const number = parseInt(numberInput.value);
            
            if (!number || number < 100 || number > 9999) {
                alert('ÊúâÂäπ„Å™Âè∞Áï™Âè∑„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºà100-9999Ôºâ');
                return;
            }
            
            saveState();
            const newCell = {
                row: pendingCellPosition.row,
                col: pendingCellPosition.col,
                type: 'machine',
                number,
            };
            layoutData.cells.push(newCell);
            addCellToIndex(newCell);
            
            const key = `${newCell.row}-${newCell.col}`;
            markDirty();
            closeModal('machineModal');
            updateCells([key]);
        }
        
        function addLabelFromModal() {
            const labelInput = document.getElementById('labelInput');
            const text = labelInput.value.trim();
            
            // ÁØÑÂõ≤ÈÅ∏Êäû„ÅÆÂ†¥Âêà
            if (pendingRangeSelection) {
                const { minRow, maxRow, minCol, maxCol, objectType } = pendingRangeSelection;
                const mergeRows = maxRow - minRow + 1;
                const mergeCols = maxCol - minCol + 1;
                
                saveState();
                
                // ÁØÑÂõ≤ÂÜÖ„ÅÆÊó¢Â≠ò„Çª„É´„ÇíÂâäÈô§
                for (let r = minRow; r <= maxRow; r++) {
                    for (let c = minCol; c <= maxCol; c++) {
                        const existing = cellSpatialIndex.get(`${r}-${c}`);
                        if (existing) {
                            removeCellFromIndex(existing);
                            const index = layoutData.cells.indexOf(existing);
                            if (index >= 0) layoutData.cells.splice(index, 1);
                        }
                    }
                }
                
                // ÁµêÂêà„Åï„Çå„ÅüÊßãÈÄ†Áâ©„ÇíËøΩÂä†ÔºàÂ∑¶‰∏ä„ÅÆ„Çª„É´„Å´ÈÖçÁΩÆÔºâ
                let newCell;
                if (objectType === 'label') {
                    newCell = {
                        row: minRow,
                        col: minCol,
                        type: 'label',
                        text: text || '',
                        mergeRows,
                        mergeCols,
                    };
                } else {
                    newCell = {
                        row: minRow,
                        col: minCol,
                        type: 'structure',
                        subtype: objectType,
                        label: text || '',
                        mergeRows,
                        mergeCols,
                    };
                }
                layoutData.cells.push(newCell);
                addCellToIndex(newCell);
                
                pendingRangeSelection = null;
                selectedCells.clear();
                markDirty();
                closeModal('labelModal');
                document.getElementById('labelModalTitle').textContent = '„É©„Éô„É´„ÇíÂÖ•Âäõ';
                renderGrid(); // „Éû„Éº„Ç∏„Çª„É´„ÅÆËøΩÂä†„ÅØ„Éï„É´„É™„Éì„É´„Éâ
                return;
            }
            
            // Âçò‰∏Ä„Çª„É´„ÅÆÂ†¥ÂêàÔºà„É©„Éô„É´„Çø„Ç§„Éó„ÅÆÊôÇ„Å†„Åë„ÉÜ„Ç≠„Çπ„ÉàÂøÖÈ†àÔºâ
            if (selectedObjectType === 'label' && !text) {
                alert('„É©„Éô„É´„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
                return;
            }
            
            saveState();
            const labelCell = {
                row: pendingCellPosition.row,
                col: pendingCellPosition.col,
                type: 'label',
                text,
            };
            layoutData.cells.push(labelCell);
            addCellToIndex(labelCell);
            
            const labelKey = `${labelCell.row}-${labelCell.col}`;
            markDirty();
            closeModal('labelModal');
            updateCells([labelKey]);
        }
        
        function showGridSettings() {
            if (!layoutData) return;
            
            document.getElementById('gridRowsInput').value = layoutData.grid.rows;
            document.getElementById('gridColsInput').value = layoutData.grid.cols;
            openModal('gridModal');
        }
        
        function applyGridSettings() {
            const newRows = parseInt(document.getElementById('gridRowsInput').value);
            const newCols = parseInt(document.getElementById('gridColsInput').value);
            const rowExpand = document.querySelector('input[name="rowExpand"]:checked').value;
            const colExpand = document.querySelector('input[name="colExpand"]:checked').value;
            
            if (!newRows || !newCols || newRows < 1 || newCols < 1) {
                alert('ÊúâÂäπ„Å™ÂÄ§„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
                return;
            }
            
            saveState();
            
            const oldRows = layoutData.grid.rows;
            const oldCols = layoutData.grid.cols;
            const rowDiff = newRows - oldRows;
            const colDiff = newCols - oldCols;
            
            // ‰∏ä„Åæ„Åü„ÅØÂ∑¶„Åã„ÇâÊã°Âºµ/Á∏ÆÂ∞è„Åô„ÇãÂ†¥Âêà„ÄÅÊó¢Â≠ò„ÅÆ„Çª„É´„Çí„Ç∑„Éï„Éà
            if (rowExpand === 'top' && rowDiff !== 0) {
                layoutData.cells.forEach(cell => {
                    cell.row += rowDiff;
                });
            }
            
            if (colExpand === 'left' && colDiff !== 0) {
                layoutData.cells.forEach(cell => {
                    cell.col += colDiff;
                });
            }
            
            layoutData.grid.rows = newRows;
            layoutData.grid.cols = newCols;
            
            // ÁØÑÂõ≤Â§ñ„ÅÆ„Çª„É´„ÇíÂâäÈô§Ôºà„Ç∑„Éï„ÉàÂæåÔºâ
            layoutData.cells = layoutData.cells.filter(c => 
                c.row >= 0 && c.row < newRows && c.col >= 0 && c.col < newCols
            );
            
            markDirty();
            closeModal('gridModal');
            renderGrid();
            updateStatus();
        }
        
        // ============================================================================
        // „Éó„É≠„Éë„ÉÜ„Ç£„Éë„Éç„É´
        // ============================================================================
        
        function updatePropertyPanel() {
            const content = document.getElementById('propertyContent');
            
            if (selectedCells.size === 0) {
                content.innerHTML = '<div style="color: var(--text-secondary); font-size: 12px;">„Çª„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ</div>';
                return;
            }
            
            if (selectedCells.size === 1) {
                const key = Array.from(selectedCells)[0];
                const [row, col] = key.split('-').map(Number);
                const cellData = cellSpatialIndex.get(key);
                
                if (cellData) {
                    content.innerHTML = renderCellProperties(cellData, row, col);
                    setupPropertyEvents(cellData);
                } else {
                    // Á©∫„ÅÆ„Çª„É´ - „Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÈÖçÁΩÆ„Éú„Çø„É≥„ÇíË°®Á§∫
                    content.innerHTML = `
                        <div class="property-row">
                            <span class="property-label">‰ΩçÁΩÆ</span>
                            <span class="property-value">Ë°å ${row}, Âàó ${col}</span>
                        </div>
                        <div style="color: var(--text-secondary); font-size: 12px; margin-bottom: 12px;">Á©∫„ÅÆ„Çª„É´</div>
                        <button class="property-btn" id="placeObjectBtn" style="background-color: var(--accent-blue); border-color: var(--accent-blue); color: white;">
                            „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÈÖçÁΩÆ
                        </button>
                    `;
                    document.getElementById('placeObjectBtn')?.addEventListener('click', placeObjectInRange);
                }
            } else {
                // ÁØÑÂõ≤ÈÅ∏ÊäûÊôÇ
                const keys = Array.from(selectedCells);
                const rows = keys.map(k => parseInt(k.split('-')[0]));
                const cols = keys.map(k => parseInt(k.split('-')[1]));
                const minRow = Math.min(...rows);
                const maxRow = Math.max(...rows);
                const minCol = Math.min(...cols);
                const maxCol = Math.max(...cols);
                
                content.innerHTML = `
                    <div class="property-row">
                        <span class="property-label">ÈÅ∏ÊäûÁØÑÂõ≤</span>
                        <span class="property-value">${maxRow - minRow + 1}Ë°å √ó ${maxCol - minCol + 1}Âàó</span>
                    </div>
                    <div class="property-row">
                        <span class="property-label">„Çª„É´Êï∞</span>
                        <span class="property-value">${selectedCells.size}„Çª„É´</span>
                    </div>
                    <button class="property-btn" id="placeObjectBtn" style="background-color: var(--accent-blue); border-color: var(--accent-blue); color: white; margin-bottom: 8px;">
                        „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÈÖçÁΩÆ
                    </button>
                    <button class="property-btn danger" id="deleteSelectedBtn">ÈÅ∏Êäû„ÇíÂâäÈô§</button>
                `;
                document.getElementById('deleteSelectedBtn')?.addEventListener('click', deleteSelected);
                document.getElementById('placeObjectBtn')?.addEventListener('click', placeObjectInRange);
            }
        }
        
        function renderCellProperties(cellData, row, col) {
            let html = `
                <div class="property-row">
                    <span class="property-label">‰ΩçÁΩÆ</span>
                    <span class="property-value">Ë°å ${row}, Âàó ${col}</span>
                </div>
            `;
            
            if (cellData.type === 'machine') {
                html += `
                    <div class="property-row">
                        <label class="property-label">Âè∞Áï™Âè∑</label>
                        <input type="number" id="propMachineNumber" class="property-input" value="${cellData.number}">
                    </div>
                `;
            } else if (cellData.type === 'structure') {
                html += `
                    <div class="property-row">
                        <span class="property-label">„Çø„Ç§„Éó</span>
                        <span class="property-value">${getObjectTypeName(cellData.subtype)}</span>
                    </div>
                    <div class="property-row">
                        <label class="property-label">„É©„Éô„É´</label>
                        <input type="text" id="propLabel" class="property-input" value="${cellData.label || ''}">
                    </div>
                    <div class="property-row">
                        <label class="property-label">„Çµ„Ç§„Ç∫</label>
                        <div style="display: flex; gap: 4px; align-items: center;">
                            <input type="number" id="propMergeRows" class="property-input" style="width: 50px;" value="${cellData.mergeRows || 1}" min="1">
                            <span>Ë°å</span>
                            <span style="margin: 0 4px;">√ó</span>
                            <input type="number" id="propMergeCols" class="property-input" style="width: 50px;" value="${cellData.mergeCols || 1}" min="1">
                            <span>Âàó</span>
                        </div>
                    </div>
                `;
            } else if (cellData.type === 'label') {
                html += `
                    <div class="property-row">
                        <label class="property-label">„ÉÜ„Ç≠„Çπ„Éà</label>
                        <input type="text" id="propText" class="property-input" value="${cellData.text || ''}">
                    </div>
                    <div class="property-row">
                        <label class="property-label">„Çµ„Ç§„Ç∫</label>
                        <div style="display: flex; gap: 4px; align-items: center;">
                            <input type="number" id="propMergeRows" class="property-input" style="width: 50px;" value="${cellData.mergeRows || 1}" min="1">
                            <span>Ë°å</span>
                            <span style="margin: 0 4px;">√ó</span>
                            <input type="number" id="propMergeCols" class="property-input" style="width: 50px;" value="${cellData.mergeCols || 1}" min="1">
                            <span>Âàó</span>
                        </div>
                    </div>
                `;
            }
            
            html += '<button class="property-btn danger" id="deleteCellBtn">ÂâäÈô§</button>';
            
            return html;
        }
        
        function setupPropertyEvents(cellData) {
            document.getElementById('deleteCellBtn')?.addEventListener('click', () => {
                saveState();
                const key = `${cellData.row}-${cellData.col}`;
                const needsFullRebuild = (cellData.mergeRows || 1) > 1 || (cellData.mergeCols || 1) > 1;
                removeCellFromIndex(cellData);
                const index = layoutData.cells.indexOf(cellData);
                if (index >= 0) {
                    layoutData.cells.splice(index, 1);
                    selectedCells.clear();
                    markDirty();
                    if (needsFullRebuild) {
                        renderGrid(); // „Éû„Éº„Ç∏„Çª„É´ÂâäÈô§„ÅØ„Éï„É´„É™„Éì„É´„Éâ
                    } else {
                        updateCells([key]);
                    }
                    updatePropertyPanel();
                }
            });
            
            // „Éó„É≠„Éë„ÉÜ„Ç£Â§âÊõ¥„ÅØ„Éá„Éê„Ç¶„É≥„Çπ„Åß‰øùÂ≠òÔºàÈÄ£Á∂öÂÖ•ÂäõÂØæÂøúÔºâ
            document.getElementById('propMachineNumber')?.addEventListener('change', (e) => {
                saveStateDebounced();
                cellData.number = parseInt(e.target.value);
                markDirty();
                updateCells([`${cellData.row}-${cellData.col}`]);
            });
            
            document.getElementById('propLabel')?.addEventListener('change', (e) => {
                saveStateDebounced();
                cellData.label = e.target.value;
                markDirty();
                updateCells([`${cellData.row}-${cellData.col}`]);
            });
            
            document.getElementById('propText')?.addEventListener('change', (e) => {
                saveStateDebounced();
                cellData.text = e.target.value;
                markDirty();
                updateCells([`${cellData.row}-${cellData.col}`]);
            });
            
            // ÊßãÈÄ†Áâ©„Çµ„Ç§„Ç∫Â§âÊõ¥Ôºà„Éû„Éº„Ç∏Â§âÊõ¥„ÅØ„Éï„É´„É™„Éì„É´„Éâ„ÅåÂøÖË¶ÅÔºâ
            document.getElementById('propMergeRows')?.addEventListener('change', (e) => {
                const newRows = parseInt(e.target.value) || 1;
                if (newRows < 1) return;
                
                const row = cellData.row;
                const col = cellData.col;
                const newMergeCols = cellData.mergeCols || 1;
                
                if (checkOverlap(row, col, newRows, newMergeCols, cellData)) {
                    alert('‰ªñ„ÅÆ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Å®ÈáçË§á„Åó„Åæ„Åô');
                    e.target.value = cellData.mergeRows || 1;
                    return;
                }
                
                saveState();
                // „Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Åã„ÇâÊóßÁä∂ÊÖã„ÇíÂâäÈô§„Åó„Å¶„Åã„ÇâÂ§âÊõ¥
                removeCellFromIndex(cellData);
                cellData.mergeRows = newRows;
                if (cellData.mergeRows === 1 && (cellData.mergeCols || 1) === 1) {
                    delete cellData.mergeRows;
                    delete cellData.mergeCols;
                }
                addCellToIndex(cellData);
                markDirty();
                renderGrid(); // „Éû„Éº„Ç∏Â§âÊõ¥„ÅØ„Éï„É´„É™„Éì„É´„Éâ
                updatePropertyPanel();
            });
            
            document.getElementById('propMergeCols')?.addEventListener('change', (e) => {
                const newCols = parseInt(e.target.value) || 1;
                if (newCols < 1) return;
                
                const row = cellData.row;
                const col = cellData.col;
                const newMergeRows = cellData.mergeRows || 1;
                
                if (checkOverlap(row, col, newMergeRows, newCols, cellData)) {
                    alert('‰ªñ„ÅÆ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Å®ÈáçË§á„Åó„Åæ„Åô');
                    e.target.value = cellData.mergeCols || 1;
                    return;
                }
                
                saveState();
                removeCellFromIndex(cellData);
                cellData.mergeCols = newCols;
                if ((cellData.mergeRows || 1) === 1 && cellData.mergeCols === 1) {
                    delete cellData.mergeRows;
                    delete cellData.mergeCols;
                }
                addCellToIndex(cellData);
                markDirty();
                renderGrid(); // „Éû„Éº„Ç∏Â§âÊõ¥„ÅØ„Éï„É´„É™„Éì„É´„Éâ
                updatePropertyPanel();
            });
        }
        
        // ÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØÔºàËá™Ë∫´„ÇíÈô§„ÅèÔºâ - Á©∫Èñì„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Åß O(mergeArea) „Å´ÊúÄÈÅ©Âåñ
        function checkOverlap(row, col, mergeRows, mergeCols, excludeCell) {
            const excludeRowEnd = excludeCell ? excludeCell.row + (excludeCell.mergeRows || 1) : -1;
            const excludeColEnd = excludeCell ? excludeCell.col + (excludeCell.mergeCols || 1) : -1;
            
            for (let r = row; r < row + mergeRows; r++) {
                for (let c = col; c < col + mergeCols; c++) {
                    const key = `${r}-${c}`;
                    
                    // „Åì„ÅÆ‰ΩçÁΩÆ„Å´„Çª„É´„Åå„ÅÇ„Çã„ÅãÔºàÁõ¥Êé•ÈÖçÁΩÆÔºâ
                    const existing = cellSpatialIndex.get(key);
                    if (existing && existing !== excludeCell) return true;
                    
                    // „Åì„ÅÆ‰ΩçÁΩÆ„Åå„Éû„Éº„Ç∏„Åï„Çå„ÅüÂ≠ê„Çª„É´„Åã
                    if (mergedCellsIndex.has(key)) {
                        // excludeCell „ÅÆ„Éû„Éº„Ç∏ÁØÑÂõ≤ÂÜÖ„Å™„ÇâÁÑ°Ë¶ñ
                        if (excludeCell &&
                            r >= excludeCell.row && r < excludeRowEnd &&
                            c >= excludeCell.col && c < excludeColEnd) {
                            continue;
                        }
                        return true;
                    }
                }
            }
            return false;
        }
        
        function deleteSelected() {
            if (selectedCells.size === 0) return;
            
            saveState();
            const changedKeys = [];
            let needsFullRebuild = false;
            
            selectedCells.forEach(key => {
                const cellData = cellSpatialIndex.get(key);
                if (cellData) {
                    if ((cellData.mergeRows || 1) > 1 || (cellData.mergeCols || 1) > 1) {
                        needsFullRebuild = true;
                    }
                    removeCellFromIndex(cellData);
                    const index = layoutData.cells.indexOf(cellData);
                    if (index >= 0) {
                        layoutData.cells.splice(index, 1);
                    }
                    changedKeys.push(key);
                }
            });
            
            selectedCells.clear();
            markDirty();
            
            if (needsFullRebuild) {
                renderGrid(); // „Éû„Éº„Ç∏„Çª„É´ÂâäÈô§„ÅØ„Éï„É´„É™„Éì„É´„Éâ
            } else {
                updateCells(changedKeys);
            }
            updatePropertyPanel();
        }
        
        // ============================================================================
        // Undo/Redo
        // ============================================================================
        
        // Âç≥ÊôÇ‰øùÂ≠òÔºà„ÇØ„É™„ÉÉ„ÇØÊìç‰Ωú„Å™„Å©Ôºâ
        function saveState() {
            PerfLogger.measure('saveState', () => {
                // „Éá„Éê„Ç¶„É≥„Çπ‰∏≠„ÅÆ„Çø„Ç§„Éû„Éº„Åå„ÅÇ„Çå„Å∞„Ç≠„É£„É≥„Çª„É´
                if (saveStateTimer) {
                    clearTimeout(saveStateTimer);
                    saveStateTimer = null;
                }
                undoStack.push(structuredClone(layoutData));
                redoStack = [];
                
                // „Çπ„Çø„ÉÉ„ÇØ„Çµ„Ç§„Ç∫„ÇíÂà∂Èôê
                if (undoStack.length > 50) {
                    undoStack.shift();
                }
            });
        }
        
        // „Éá„Éê„Ç¶„É≥„Çπ‰øùÂ≠òÔºà„Éó„É≠„Éë„ÉÜ„Ç£Â§âÊõ¥„Å™„Å©ÈÄ£Á∂öÂÖ•ÂäõÊôÇÔºâ
        let saveStateTimer = null;
        function saveStateDebounced() {
            if (saveStateTimer) clearTimeout(saveStateTimer);
            saveStateTimer = setTimeout(() => {
                saveStateTimer = null;
                undoStack.push(structuredClone(layoutData));
                redoStack = [];
                if (undoStack.length > 50) undoStack.shift();
            }, 300);
        }
        
        function undo() {
            if (undoStack.length === 0) return;
            
            redoStack.push(structuredClone(layoutData));
            layoutData = undoStack.pop();
            selectedCells.clear();
            markDirty();
            renderGrid(); // undo „ÅØ„Éï„É´„É™„Éì„É´„ÉâÔºàÊßãÈÄ†„ÅåÂ§ß„Åç„ÅèÂ§â„Çè„Çä„ÅÜ„ÇãÔºâ
            updatePropertyPanel();
        }
        
        function redo() {
            if (redoStack.length === 0) return;
            
            undoStack.push(structuredClone(layoutData));
            layoutData = redoStack.pop();
            selectedCells.clear();
            markDirty();
            renderGrid(); // redo „ÅØ„Éï„É´„É™„Éì„É´„Éâ
            updatePropertyPanel();
        }
        
        // ============================================================================
        // „Ç≠„Éº„Éú„Éº„Éâ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà
        // ============================================================================
        
        function handleKeydown(e) {
            // „É¢„Éº„ÉÄ„É´„ÅåÈñã„ÅÑ„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØÁÑ°Ë¶ñ
            if (document.querySelector('.modal-overlay.active')) return;
            
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 's') {
                    e.preventDefault();
                    saveLayout();
                } else if (e.key === 'z') {
                    e.preventDefault();
                    if (e.shiftKey) {
                        redo();
                    } else {
                        undo();
                    }
                }
            } else {
                switch (e.key) {
                    case 'Delete':
                    case 'Backspace':
                        if (selectedCells.size > 0) {
                            e.preventDefault();
                            deleteSelected();
                        }
                        break;
                    case 'Escape':
                        {
                            const oldSel = new Set(selectedCells);
                            selectedCells.clear();
                            updateSelection(oldSel, selectedCells);
                            updatePropertyPanel();
                        }
                        break;
                }
            }
        }
        
        // ============================================================================
        // „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£
        // ============================================================================
        
        function markDirty() {
            isDirty = true;
            updateStatus();
        }
        
        function updateStatus() {
            if (!layoutData) {
                document.getElementById('statusHole').textContent = 'Â∫óËàó: Êú™ÈÅ∏Êäû';
                document.getElementById('statusGrid').textContent = '„Ç∞„É™„ÉÉ„Éâ: -';
                document.getElementById('statusCells').textContent = '„Çª„É´Êï∞: -';
                document.getElementById('statusSource').textContent = '„ÇΩ„Éº„Çπ: -';
                return;
            }
            
            document.getElementById('statusHole').textContent = `Â∫óËàó: ${layoutData.hole}`;
            document.getElementById('statusGrid').textContent = `„Ç∞„É™„ÉÉ„Éâ: ${layoutData.grid.rows}√ó${layoutData.grid.cols}`;
            document.getElementById('statusCells').textContent = `„Çª„É´Êï∞: ${layoutData.cells.length}`;
            document.getElementById('statusSource').textContent = `„ÇΩ„Éº„Çπ: ${layoutSource || 'unknown'}`;
            
            if (isDirty) {
                document.getElementById('statusMessage').textContent = 'Êú™‰øùÂ≠ò„ÅÆÂ§âÊõ¥„Åå„ÅÇ„Çä„Åæ„Åô';
            }
        }
        
        function setMessage(msg) {
            document.getElementById('statusMessage').textContent = msg;
        }
        
        // ============================================================================
        // ÂàùÊúüÂåñÂÆüË°å
        // ============================================================================
        init();
    </script>
</body>
</html>
