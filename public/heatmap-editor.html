<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆç·¨é›† - Yobun</title>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --border-color: #30363d;
            --text-primary: #c9d1d9;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-yellow: #d29922;
            --accent-red: #f85149;
            --accent-orange: #f0883e;
            --cell-size: 40px;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.5;
            height: 100vh;
            overflow: hidden;
        }
        
        /* ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        /* ãƒ˜ãƒƒãƒ€ãƒ¼ */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 16px;
            background-color: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        
        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        h1 {
            font-size: 16px;
            font-weight: 600;
        }
        
        .header-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        select {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            padding: 6px 10px;
            font-size: 13px;
        }
        
        nav {
            display: flex;
            gap: 12px;
        }
        
        nav a {
            color: var(--accent-blue);
            text-decoration: none;
            font-size: 13px;
        }
        
        /* ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ */
        .toolbar {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background-color: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        
        .tool-group {
            display: flex;
            gap: 4px;
            padding-right: 12px;
            border-right: 1px solid var(--border-color);
        }
        
        .tool-group:last-child {
            border-right: none;
        }
        
        .tool-btn {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .tool-btn:hover {
            background-color: #2d333b;
        }
        
        .tool-btn.active {
            background-color: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }
        
        .tool-btn.save-btn {
            background-color: var(--accent-green);
            border-color: var(--accent-green);
            color: white;
        }
        
        .tool-btn.save-btn:hover {
            opacity: 0.9;
        }
        
        /* ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ */
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        /* ã‚µã‚¤ãƒ‰ãƒ‘ãƒãƒ« */
        .side-panel {
            width: 180px;
            background-color: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }
        
        .panel-section {
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .panel-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 8px;
        }
        
        .structure-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .structure-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }
        
        .structure-item:hover {
            border-color: var(--accent-blue);
        }
        
        .structure-item.selected {
            border-color: var(--accent-blue);
            background-color: rgba(88, 166, 255, 0.1);
        }
        
        .structure-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            font-size: 10px;
        }
        
        .structure-icon.escalator { background-color: #2a4a5a; }
        .structure-icon.stairs { background-color: #2a4a5a; }
        .structure-icon.counter { background-color: #5a4a3a; }
        .structure-icon.locker { background-color: #4a3a5a; }
        .structure-icon.vending { background-color: #3a5a4a; }
        .structure-icon.shelf { background-color: #4a4535; }
        .structure-icon.pillar { background-color: #5a5a5a; }
        .structure-icon.label { background-color: #2a2f38; }
        
        /* ã‚°ãƒªãƒƒãƒ‰ã‚³ãƒ³ãƒ†ãƒŠ */
        .grid-container {
            flex: 1;
            overflow: hidden;
            padding: 16px;
            background-color: var(--bg-primary);
            touch-action: none;
        }
        
        .editor-grid {
            display: grid;
            gap: 1px;
            background-color: var(--border-color);
            width: fit-content;
            border: 1px solid var(--border-color);
        }
        
        /* ã‚»ãƒ« */
        .editor-cell {
            min-width: var(--cell-size);
            min-height: var(--cell-size);
            background-color: var(--bg-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            cursor: pointer;
            position: relative;
            user-select: none;
        }
        
        .editor-cell:hover {
            outline: 2px solid var(--accent-blue);
            outline-offset: -2px;
            z-index: 1;
        }
        
        .editor-cell.selected {
            outline: 2px solid var(--accent-green);
            outline-offset: -2px;
            z-index: 2;
        }
        
        .editor-cell.machine {
            background-color: var(--bg-tertiary);
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .editor-cell.structure {
            background-color: #3d4450;
            color: #a0aab8;
        }
        
        .editor-cell.structure.escalator { background-color: #2a4a5a; }
        .editor-cell.structure.stairs { background-color: #2a4a5a; }
        .editor-cell.structure.counter { background-color: #5a4a3a; }
        .editor-cell.structure.locker { background-color: #4a3a5a; }
        .editor-cell.structure.vending { background-color: #3a5a4a; }
        .editor-cell.structure.shelf { background-color: #4a4535; }
        .editor-cell.structure.pillar { background-color: #5a5a5a; }
        
        .editor-cell.label {
            background-color: #2a2f38;
            color: #8090a0;
        }
        
        
        /* ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ‘ãƒãƒ« */
        .property-panel {
            width: 220px;
            background-color: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }
        
        .property-content {
            padding: 12px;
        }
        
        .property-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 12px;
        }
        
        .property-label {
            font-size: 11px;
            color: var(--text-secondary);
        }
        
        .property-value {
            font-size: 13px;
            color: var(--text-primary);
        }
        
        .property-input {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            padding: 6px 8px;
            font-size: 13px;
            width: 100%;
        }
        
        .property-btn {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            width: 100%;
            margin-top: 4px;
        }
        
        .property-btn:hover {
            background-color: #2d333b;
        }
        
        .property-btn.danger {
            background-color: rgba(248, 81, 73, 0.2);
            border-color: var(--accent-red);
            color: var(--accent-red);
        }
        
        /* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼ */
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 16px;
            background-color: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            font-size: 11px;
            color: var(--text-secondary);
            flex-shrink: 0;
        }
        
        .status-info {
            display: flex;
            gap: 16px;
        }
        
        /* ãƒ¢ãƒ¼ãƒ€ãƒ« */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .modal-overlay.active {
            display: flex;
        }
        
        .modal {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            min-width: 300px;
        }
        
        .modal h3 {
            margin-bottom: 16px;
            font-size: 16px;
        }
        
        .modal-buttons {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            margin-top: 16px;
        }
        
        .modal-btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            border: 1px solid var(--border-color);
        }
        
        .modal-btn.primary {
            background-color: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }
        
        .modal-btn.secondary {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        /* ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .editor-cell.dragging {
            opacity: 0.5;
        }
        
        .editor-cell.drag-over {
            background-color: rgba(88, 166, 255, 0.3) !important;
        }
        
        /* ãƒãƒ¼ã‚¸ã•ã‚ŒãŸã‚»ãƒ« */
        .editor-cell.merged-parent {
            font-size: 11px;
            padding: 8px;
            text-align: center;
            word-break: break-all;
        }
        
    </style>
</head>
<body>
    <div class="app-container">
        <!-- ãƒ˜ãƒƒãƒ€ãƒ¼ -->
        <header>
            <div class="header-left">
                <h1>ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆç·¨é›†</h1>
                <div class="header-controls">
                    <select id="holeSelect">
                        <option value="">åº—èˆ—ã‚’é¸æŠ</option>
                    </select>
                    <select id="floorSelect">
                        <option value="">ãƒ•ãƒ­ã‚¢ã‚’é¸æŠ</option>
                    </select>
                    <button class="tool-btn" id="loadBtn">èª­ã¿è¾¼ã¿</button>
                    <button class="tool-btn" id="newLayoutBtn">æ–°è¦ä½œæˆ</button>
                </div>
            </div>
            <nav>
                <a href="/heatmap">ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—è¡¨ç¤º</a>
                <a href="/dashboard">ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰</a>
            </nav>
        </header>
        
        <!-- ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ -->
        <div class="toolbar">
            <div class="tool-group">
                <button class="tool-btn" id="undoBtn" title="å…ƒã«æˆ»ã™ (Ctrl+Z)">â†© æˆ»ã™</button>
                <button class="tool-btn" id="redoBtn" title="ã‚„ã‚Šç›´ã— (Ctrl+Shift+Z)">â†ª ã‚„ã‚Šç›´ã—</button>
            </div>
            <div class="tool-group">
                <button class="tool-btn" id="zoomOutBtn" title="ç¸®å°">âˆ’</button>
                <span id="zoomLevel" style="min-width: 50px; text-align: center; padding: 0 8px;">100%</span>
                <button class="tool-btn" id="zoomInBtn" title="æ‹¡å¤§">+</button>
                <button class="tool-btn" id="zoomResetBtn" title="ãƒªã‚»ãƒƒãƒˆ">âŸ²</button>
            </div>
            <div class="tool-group">
                <button class="tool-btn" id="gridSettingsBtn" title="ã‚°ãƒªãƒƒãƒ‰è¨­å®š">âš™ ã‚°ãƒªãƒƒãƒ‰</button>
            </div>
            <div class="tool-group">
                <button class="tool-btn save-btn" id="saveBtn" title="ä¿å­˜ (Ctrl+S)">ğŸ’¾ ä¿å­˜</button>
            </div>
            <span id="fpsCounter" style="display: none; margin-left: auto; font-size: 11px; color: var(--accent-green); font-family: monospace; min-width: 60px; text-align: right;">-- FPS</span>
        </div>
        
        <!-- ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ -->
        <div class="main-content">
            <!-- ã‚µã‚¤ãƒ‰ãƒ‘ãƒãƒ«ï¼ˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒªã‚¹ãƒˆï¼‰ -->
            <div class="side-panel">
                <div class="panel-section">
                    <div class="panel-title">ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¿ã‚¤ãƒ—</div>
                    <div class="structure-list" id="structureList">
                        <div class="structure-item selected" data-subtype="machine">
                            <span class="structure-icon machine">ğŸ°</span>
                            <span>å°</span>
                        </div>
                        <div class="structure-item" data-subtype="escalator">
                            <span class="structure-icon escalator">â†‘â†“</span>
                            <span>ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚¿ãƒ¼</span>
                        </div>
                        <div class="structure-item" data-subtype="stairs">
                            <span class="structure-icon stairs">éš</span>
                            <span>éšæ®µ</span>
                        </div>
                        <div class="structure-item" data-subtype="counter">
                            <span class="structure-icon counter">C</span>
                            <span>ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼</span>
                        </div>
                        <div class="structure-item" data-subtype="locker">
                            <span class="structure-icon locker">L</span>
                            <span>ãƒ­ãƒƒã‚«ãƒ¼</span>
                        </div>
                        <div class="structure-item" data-subtype="vending">
                            <span class="structure-icon vending">V</span>
                            <span>è‡ªè²©æ©Ÿ</span>
                        </div>
                        <div class="structure-item" data-subtype="shelf">
                            <span class="structure-icon shelf">æ£š</span>
                            <span>æ£š</span>
                        </div>
                        <div class="structure-item" data-subtype="pillar">
                            <span class="structure-icon pillar">æŸ±</span>
                            <span>æŸ±</span>
                        </div>
                        <div class="structure-item" data-subtype="label">
                            <span class="structure-icon label">T</span>
                            <span>ãƒ©ãƒ™ãƒ«</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- ã‚°ãƒªãƒƒãƒ‰ã‚³ãƒ³ãƒ†ãƒŠ -->
            <div class="grid-container" id="gridContainer">
                <div class="editor-grid" id="editorGrid">
                    <!-- ã‚°ãƒªãƒƒãƒ‰ã¯JSã§ç”Ÿæˆ -->
                </div>
            </div>
            
            <!-- ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ‘ãƒãƒ« -->
            <div class="property-panel">
                <div class="panel-section">
                    <div class="panel-title">é¸æŠä¸­</div>
                    <div class="property-content" id="propertyContent">
                        <div style="color: var(--text-secondary); font-size: 12px;">
                            ã‚»ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼ -->
        <div class="status-bar">
            <div class="status-info">
                <span id="statusHole">åº—èˆ—: æœªé¸æŠ</span>
                <span id="statusFloor">ãƒ•ãƒ­ã‚¢: -</span>
                <span id="statusGrid">ã‚°ãƒªãƒƒãƒ‰: -</span>
                <span id="statusCells">ã‚»ãƒ«æ•°: -</span>
            </div>
            <div id="statusMessage">ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„</div>
        </div>
    </div>
    
    <!-- å°ç•ªå·å…¥åŠ›ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="machineModal" class="modal-overlay">
        <div class="modal">
            <h3>å°ç•ªå·ã‚’å…¥åŠ›</h3>
            <input type="number" id="machineNumberInput" class="property-input" placeholder="ä¾‹: 1205">
            <div class="modal-buttons">
                <button class="modal-btn secondary" id="machineModalCancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                <button class="modal-btn primary" id="machineModalOk">è¿½åŠ </button>
            </div>
        </div>
    </div>
    
    <!-- ãƒ©ãƒ™ãƒ«å…¥åŠ›ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="labelModal" class="modal-overlay">
        <div class="modal">
            <h3 id="labelModalTitle">ãƒ©ãƒ™ãƒ«ã‚’å…¥åŠ›</h3>
            <input type="text" id="labelInput" class="property-input" placeholder="ä¾‹: POS">
            <div class="modal-buttons">
                <button class="modal-btn secondary" id="labelModalCancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                <button class="modal-btn primary" id="labelModalOk">è¿½åŠ </button>
            </div>
        </div>
    </div>
    
    <!-- ã‚°ãƒªãƒƒãƒ‰è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="gridModal" class="modal-overlay">
        <div class="modal">
            <h3>ã‚°ãƒªãƒƒãƒ‰è¨­å®š</h3>
            <div class="property-row">
                <label class="property-label">è¡Œæ•°</label>
                <input type="number" id="gridRowsInput" class="property-input" min="1" max="200">
            </div>
            <div class="property-row">
                <label class="property-label">åˆ—æ•°</label>
                <input type="number" id="gridColsInput" class="property-input" min="1" max="200">
            </div>
            <div class="property-row" style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-color);">
                <label class="property-label">è¡Œã®æ‹¡å¼µæ–¹å‘</label>
                <div style="display: flex; gap: 12px;">
                    <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                        <input type="radio" name="rowExpand" value="bottom" checked> ä¸‹ã¸
                    </label>
                    <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                        <input type="radio" name="rowExpand" value="top"> ä¸Šã¸
                    </label>
                </div>
            </div>
            <div class="property-row">
                <label class="property-label">åˆ—ã®æ‹¡å¼µæ–¹å‘</label>
                <div style="display: flex; gap: 12px;">
                    <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                        <input type="radio" name="colExpand" value="right" checked> å³ã¸
                    </label>
                    <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                        <input type="radio" name="colExpand" value="left"> å·¦ã¸
                    </label>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="modal-btn secondary" id="gridModalCancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                <button class="modal-btn primary" id="gridModalOk">é©ç”¨</button>
            </div>
        </div>
    </div>
    
    <!-- æ–°è¦ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆä½œæˆãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="newLayoutModal" class="modal-overlay">
        <div class="modal">
            <h3>æ–°è¦ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆä½œæˆ</h3>
            <div class="property-row">
                <label class="property-label">åº—èˆ—</label>
                <select id="newLayoutHoleSelect" class="property-input">
                    <option value="">åº—èˆ—ã‚’é¸æŠ</option>
                </select>
            </div>
            <div class="property-row">
                <label class="property-label">ãƒ•ãƒ­ã‚¢å</label>
                <input type="text" id="newLayoutFloorInput" class="property-input" placeholder="ä¾‹: 1F, 2F, B1F">
            </div>
            <div class="property-row">
                <label class="property-label">ã‚°ãƒªãƒƒãƒ‰è¡Œæ•°</label>
                <input type="number" id="newLayoutRowsInput" class="property-input" min="1" max="200" value="30">
            </div>
            <div class="property-row">
                <label class="property-label">ã‚°ãƒªãƒƒãƒ‰åˆ—æ•°</label>
                <input type="number" id="newLayoutColsInput" class="property-input" min="1" max="200" value="30">
            </div>
            <div class="modal-buttons">
                <button class="modal-btn secondary" id="newLayoutModalCancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                <button class="modal-btn primary" id="newLayoutModalOk">ä½œæˆ</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨ˆæ¸¬åŸºç›¤ï¼ˆ?perf=true ã§æœ‰åŠ¹åŒ–ï¼‰
        // ============================================================================
        const PERF_ENABLED = new URLSearchParams(window.location.search).has('perf');

        const PerfLogger = {
            enabled: PERF_ENABLED,
            metrics: [],
            
            measure(label, fn) {
                if (!this.enabled) return fn();
                const start = performance.now();
                const result = fn();
                const duration = performance.now() - start;
                this.log(label, duration);
                return result;
            },
            
            async measureAsync(label, fn) {
                if (!this.enabled) return fn();
                const start = performance.now();
                const result = await fn();
                const duration = performance.now() - start;
                this.log(label, duration);
                return result;
            },
            
            log(label, duration) {
                const entry = { label, duration, timestamp: Date.now() };
                this.metrics.push(entry);
                // ãƒ¡ãƒ¢ãƒªä¸Šé™: æœ€æ–°1000ä»¶ã®ã¿ä¿æŒ
                if (this.metrics.length > 1000) this.metrics.shift();
                if (duration > 16) {
                    console.warn(`[PERF] ${label}: ${duration.toFixed(1)}ms (> 16ms frame budget)`);
                } else if (duration > 4) {
                    console.log(`[PERF] ${label}: ${duration.toFixed(1)}ms`);
                } else {
                    console.debug(`[PERF] ${label}: ${duration.toFixed(1)}ms`);
                }
            },
            
            report() {
                const grouped = {};
                this.metrics.forEach(m => {
                    if (!grouped[m.label]) {
                        grouped[m.label] = { count: 0, total: 0, max: 0, min: Infinity };
                    }
                    const g = grouped[m.label];
                    g.count++;
                    g.total += m.duration;
                    g.max = Math.max(g.max, m.duration);
                    g.min = Math.min(g.min, m.duration);
                });
                const rows = Object.entries(grouped).map(([label, g]) => ({
                    label,
                    count: g.count,
                    avg: (g.total / g.count).toFixed(1) + 'ms',
                    max: g.max.toFixed(1) + 'ms',
                    min: g.min.toFixed(1) + 'ms',
                    total: g.total.toFixed(1) + 'ms',
                }));
                console.table(rows);
                return rows;
            },
            
            clear() {
                this.metrics = [];
                console.log('[PERF] Metrics cleared');
            }
        };

        const FPSMonitor = {
            frames: 0,
            lastTime: performance.now(),
            display: null,
            running: false,
            
            start() {
                this.display = document.getElementById('fpsCounter');
                if (this.display) this.display.style.display = '';
                this.running = true;
                this.tick();
            },
            stop() {
                this.running = false;
                if (this.display) this.display.style.display = 'none';
            },
            tick() {
                if (!this.running) return;
                this.frames++;
                const now = performance.now();
                if (now - this.lastTime >= 1000) {
                    const fps = Math.round(this.frames * 1000 / (now - this.lastTime));
                    if (this.display) {
                        this.display.textContent = `${fps} FPS`;
                        this.display.style.color = fps >= 50 ? 'var(--accent-green)' : fps >= 30 ? 'var(--accent-yellow)' : 'var(--accent-red)';
                    }
                    this.frames = 0;
                    this.lastTime = now;
                }
                requestAnimationFrame(() => this.tick());
            }
        };

        // Long Task æ¤œçŸ¥ï¼ˆ50msè¶…ã®ã‚¿ã‚¹ã‚¯ã‚’è‡ªå‹•ãƒ­ã‚°ï¼‰
        if (PERF_ENABLED && typeof PerformanceObserver !== 'undefined') {
            try {
                new PerformanceObserver(list => {
                    list.getEntries().forEach(entry => {
                        console.warn(`[PERF] Long Task detected: ${entry.duration.toFixed(1)}ms`);
                    });
                }).observe({ entryTypes: ['longtask'] });
            } catch (e) { /* longtask not supported */ }
        }

        // ãƒ‡ãƒãƒƒã‚°ç”¨ã‚°ãƒ­ãƒ¼ãƒãƒ«å…¬é–‹
        if (PERF_ENABLED) {
            window.PerfLogger = PerfLogger;
            window.FPSMonitor = FPSMonitor;
        }

        // ============================================================================
        // çŠ¶æ…‹ç®¡ç†
        // ============================================================================
        let layoutData = null;
        let selectedObjectType = 'machine'; // machine, escalator, stairs, counter, locker, vending, shelf, pillar, label
        let selectedCells = new Set();
        let undoStack = [];
        let redoStack = [];
        let isDirty = false;
        
        // ãƒ‰ãƒ©ãƒƒã‚°é–¢é€£
        let isDragging = false;
        let dragStartCell = null;
        let draggedCells = [];
        
        // ç¯„å›²é¸æŠé–¢é€£
        let isRangeSelecting = false;
        let rangeSelectStart = null;
        let rangeSelectEnd = null;
        
        // ã‚»ãƒ«è¦ç´ ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆquerySelectorã‚’é¿ã‘ã‚‹ãŸã‚ï¼‰
        let cellElementCache = new Map(); // key: "row-col", value: DOM element
        
        // ç©ºé–“ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆã‚»ãƒ«ãƒ‡ãƒ¼ã‚¿ã® O(1) æ¤œç´¢ç”¨ï¼‰
        let cellSpatialIndex = new Map(); // key: "row-col" -> cellData
        let mergedCellsIndex = new Set(); // ãƒãƒ¼ã‚¸ã•ã‚ŒãŸå­ã‚»ãƒ«ã®ä½ç½®ï¼ˆkey: "row-col"ï¼‰
        
        // ã‚ºãƒ¼ãƒ ãƒ»ãƒ‘ãƒ³é–¢é€£
        let zoomLevel = 1;
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;
        let lastPanX = 0;
        let lastPanY = 0;
        
        // ã‚¿ãƒƒãƒé–¢é€£ï¼ˆãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ ç”¨ï¼‰
        let initialPinchDistance = 0;
        let initialZoom = 1;
        
        // ============================================================================
        // åˆæœŸåŒ–
        // ============================================================================
        
        async function init() {
            // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¢ãƒ‹ã‚¿ãƒ¼èµ·å‹•
            if (PERF_ENABLED) {
                FPSMonitor.start();
                console.log('[PERF] Performance monitoring enabled. Use PerfLogger.report() to view stats.');
            }
            
            // åº—èˆ—ä¸€è¦§ã‚’å–å¾—
            await loadHoleList();
            
            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            setupEventListeners();
            
            // ã‚ºãƒ¼ãƒ ãƒ»ãƒ‘ãƒ³æ©Ÿèƒ½
            setupZoomPan();
        }
        
        // ============================================================================
        // ç©ºé–“ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç®¡ç†
        // ============================================================================
        
        function rebuildSpatialIndex() {
            cellSpatialIndex.clear();
            mergedCellsIndex.clear();
            if (!layoutData) return;
            
            layoutData.cells.forEach(cell => {
                cellSpatialIndex.set(`${cell.row}-${cell.col}`, cell);
                if (cell.mergeRows > 1 || cell.mergeCols > 1) {
                    const mr = cell.mergeRows || 1;
                    const mc = cell.mergeCols || 1;
                    for (let r = 0; r < mr; r++) {
                        for (let c = 0; c < mc; c++) {
                            if (r !== 0 || c !== 0) {
                                mergedCellsIndex.add(`${cell.row + r}-${cell.col + c}`);
                            }
                        }
                    }
                }
            });
        }
        
        function addCellToIndex(cell) {
            cellSpatialIndex.set(`${cell.row}-${cell.col}`, cell);
            if (cell.mergeRows > 1 || cell.mergeCols > 1) {
                const mr = cell.mergeRows || 1;
                const mc = cell.mergeCols || 1;
                for (let r = 0; r < mr; r++) {
                    for (let c = 0; c < mc; c++) {
                        if (r !== 0 || c !== 0) {
                            mergedCellsIndex.add(`${cell.row + r}-${cell.col + c}`);
                        }
                    }
                }
            }
        }
        
        function removeCellFromIndex(cell) {
            cellSpatialIndex.delete(`${cell.row}-${cell.col}`);
            if (cell.mergeRows > 1 || cell.mergeCols > 1) {
                const mr = cell.mergeRows || 1;
                const mc = cell.mergeCols || 1;
                for (let r = 0; r < mr; r++) {
                    for (let c = 0; c < mc; c++) {
                        if (r !== 0 || c !== 0) {
                            mergedCellsIndex.delete(`${cell.row + r}-${cell.col + c}`);
                        }
                    }
                }
            }
        }
        
        async function loadHoleList() {
            try {
                const response = await fetch('/api/heatmap/layouts');
                const data = await response.json();
                const holes = [...new Set((data.layouts || []).map((l) => l.hole))].filter(Boolean).sort();
                
                const select = document.getElementById('holeSelect');
                select.innerHTML = '<option value="">åº—èˆ—ã‚’é¸æŠ</option>';
                holes.forEach((hole) => {
                    const option = document.createElement('option');
                    option.value = hole;
                    option.textContent = hole;
                    select.appendChild(option);
                });
                
                document.getElementById('floorSelect').innerHTML = '<option value="">ãƒ•ãƒ­ã‚¢ã‚’é¸æŠ</option>';
            } catch (error) {
                console.error('åº—èˆ—ä¸€è¦§å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
            }
        }
        
        async function loadFloorList(hole) {
            const floorSelect = document.getElementById('floorSelect');
            floorSelect.innerHTML = '<option value="">ãƒ•ãƒ­ã‚¢ã‚’é¸æŠ</option>';
            if (!hole) return;
            try {
                const response = await fetch(`/api/heatmap/layouts/${encodeURIComponent(hole)}`);
                const data = await response.json();
                (data.floors || []).forEach((floor) => {
                    const option = document.createElement('option');
                    option.value = floor;
                    option.textContent = floor;
                    floorSelect.appendChild(option);
                });
            } catch (error) {
                console.error('ãƒ•ãƒ­ã‚¢ä¸€è¦§å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
            }
        }
        
        function setupEventListeners() {
            document.getElementById('holeSelect').addEventListener('change', () => {
                const hole = document.getElementById('holeSelect').value;
                loadFloorList(hole);
            });
            
            document.getElementById('loadBtn').addEventListener('click', loadLayout);
            document.getElementById('newLayoutBtn').addEventListener('click', showNewLayoutModal);
            
            // ä¿å­˜ãƒœã‚¿ãƒ³
            document.getElementById('saveBtn').addEventListener('click', saveLayout);
            
            // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¿ã‚¤ãƒ—é¸æŠ
            document.querySelectorAll('.structure-item').forEach(item => {
                item.addEventListener('click', () => selectObjectType(item.dataset.subtype));
            });
            
            // ã‚ºãƒ¼ãƒ ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
            document.getElementById('zoomInBtn').addEventListener('click', zoomIn);
            document.getElementById('zoomOutBtn').addEventListener('click', zoomOut);
            document.getElementById('zoomResetBtn').addEventListener('click', resetZoom);
            
            // Undo/Redo
            document.getElementById('undoBtn').addEventListener('click', undo);
            document.getElementById('redoBtn').addEventListener('click', redo);
            
            // ã‚°ãƒªãƒƒãƒ‰è¨­å®š
            document.getElementById('gridSettingsBtn').addEventListener('click', showGridSettings);
            document.getElementById('gridModalCancel').addEventListener('click', () => closeModal('gridModal'));
            document.getElementById('gridModalOk').addEventListener('click', applyGridSettings);
            
            document.getElementById('newLayoutModalCancel').addEventListener('click', () => closeModal('newLayoutModal'));
            document.getElementById('newLayoutModalOk').addEventListener('click', createNewLayout);
            
            // å°ç•ªå·ãƒ¢ãƒ¼ãƒ€ãƒ«
            document.getElementById('machineModalCancel').addEventListener('click', () => closeModal('machineModal'));
            document.getElementById('machineModalOk').addEventListener('click', addMachineFromModal);
            document.getElementById('machineNumberInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addMachineFromModal();
            });
            
            // ãƒ©ãƒ™ãƒ«ãƒ¢ãƒ¼ãƒ€ãƒ«
            document.getElementById('labelModalCancel').addEventListener('click', () => closeModal('labelModal'));
            document.getElementById('labelModalOk').addEventListener('click', addLabelFromModal);
            document.getElementById('labelInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addLabelFromModal();
            });
            
            // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
            document.addEventListener('keydown', handleKeydown);
            
            // ã‚°ãƒªãƒƒãƒ‰ã®ã‚¤ãƒ™ãƒ³ãƒˆå§”è­²ï¼ˆã‚»ãƒ«ã”ã¨ã«ãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ ã™ã‚‹ä»£ã‚ã‚Šã«ã€ã‚°ãƒªãƒƒãƒ‰ã«1ã¤ã ã‘è¿½åŠ ï¼‰
            const grid = document.getElementById('editorGrid');
            grid.addEventListener('click', (e) => {
                const cell = e.target.closest('.editor-cell');
                if (!cell) return;
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                handleCellClick(e, row, col);
            });
            grid.addEventListener('mousedown', (e) => {
                const cell = e.target.closest('.editor-cell');
                if (!cell) return;
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                handleCellMouseDown(e, row, col);
            });
            grid.addEventListener('mouseenter', (e) => {
                const cell = e.target.closest('.editor-cell');
                if (!cell) return;
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                handleCellMouseEnter(e, row, col);
            }, true); // ã‚­ãƒ£ãƒ—ãƒãƒ£ãƒ•ã‚§ãƒ¼ã‚ºã§å‡¦ç†ï¼ˆå­è¦ç´ ã¸ã®enterã‚‚æ¤œçŸ¥ï¼‰
            grid.addEventListener('mouseup', (e) => {
                const cell = e.target.closest('.editor-cell');
                if (!cell) return;
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                handleCellMouseUp(e, row, col);
            });
            // mouseover ã¯ mouseenter (capture) ã¨é‡è¤‡ã™ã‚‹ãŸã‚å‰Šé™¤
        }
        
        // ============================================================================
        // ã‚ºãƒ¼ãƒ ãƒ»ãƒ‘ãƒ³æ©Ÿèƒ½
        // ============================================================================
        
        // ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼æŠ¼ä¸‹çŠ¶æ…‹
        let isSpacePressed = false;
        
        function setupZoomPan() {
            const container = document.getElementById('gridContainer');
            const grid = document.getElementById('editorGrid');
            
            // ãƒ›ã‚¤ãƒ¼ãƒ«ã§ã‚ºãƒ¼ãƒ ï¼ˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç„¡åŠ¹åŒ–ï¼‰
            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -0.1 : 0.1;
                const newZoom = Math.max(0.2, Math.min(3, zoomLevel + delta));
                
                // ãƒã‚¦ã‚¹ä½ç½®ã‚’ä¸­å¿ƒã«ã‚ºãƒ¼ãƒ 
                const rect = container.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // ã‚ºãƒ¼ãƒ å‰ã®ãƒã‚¦ã‚¹ä½ç½®ï¼ˆã‚°ãƒªãƒƒãƒ‰åº§æ¨™ï¼‰
                const gridX = (mouseX - panX) / zoomLevel;
                const gridY = (mouseY - panY) / zoomLevel;
                
                zoomLevel = newZoom;
                
                // ã‚ºãƒ¼ãƒ å¾Œã®ãƒã‚¦ã‚¹ä½ç½®ã‚’ä¿æŒã™ã‚‹ã‚ˆã†ã«ãƒ‘ãƒ³èª¿æ•´
                panX = mouseX - gridX * zoomLevel;
                panY = mouseY - gridY * zoomLevel;
                
                applyZoomPan();
            }, { passive: false });
            
            // ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§ãƒ‘ãƒ³ãƒ¢ãƒ¼ãƒ‰ï¼ˆãƒ¢ãƒ¼ãƒ€ãƒ«ãŒé–‹ã„ã¦ã„ãªã„å ´åˆã®ã¿ï¼‰
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space' && !isSpacePressed && !document.querySelector('.modal-overlay.active')) {
                    e.preventDefault();
                    isSpacePressed = true;
                    container.style.cursor = 'grab';
                }
            });
            
            document.addEventListener('keyup', (e) => {
                if (e.code === 'Space') {
                    isSpacePressed = false;
                    if (!isPanning) {
                        container.style.cursor = '';
                    }
                }
            });
            
            // ã‚¹ãƒšãƒ¼ã‚¹+å·¦ã‚¯ãƒªãƒƒã‚¯ ã¾ãŸã¯ ä¸­ãƒœã‚¿ãƒ³ã§ãƒ‘ãƒ³
            container.addEventListener('mousedown', (e) => {
                if (e.button === 1 || (e.button === 0 && isSpacePressed)) {
                    e.preventDefault();
                    isPanning = true;
                    panStartX = e.clientX;
                    panStartY = e.clientY;
                    lastPanX = panX;
                    lastPanY = panY;
                    container.style.cursor = 'grabbing';
                }
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isPanning) {
                    panX = lastPanX + (e.clientX - panStartX);
                    panY = lastPanY + (e.clientY - panStartY);
                    applyZoomPan();
                }
            });
            
            document.addEventListener('mouseup', () => {
                if (isPanning) {
                    isPanning = false;
                    document.getElementById('gridContainer').style.cursor = isSpacePressed ? 'grab' : '';
                }
            });
            
            // ã‚¿ãƒƒãƒæ“ä½œï¼ˆãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ ã€2æœ¬æŒ‡ãƒ‘ãƒ³ï¼‰
            container.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    initialPinchDistance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );
                    initialZoom = zoomLevel;
                    
                    // ãƒ‘ãƒ³ã®é–‹å§‹ä½ç½®
                    const centerX = (touch1.clientX + touch2.clientX) / 2;
                    const centerY = (touch1.clientY + touch2.clientY) / 2;
                    panStartX = centerX;
                    panStartY = centerY;
                    lastPanX = panX;
                    lastPanY = panY;
                }
            }, { passive: false });
            
            container.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    
                    // ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ 
                    const currentDistance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );
                    const scale = currentDistance / initialPinchDistance;
                    zoomLevel = Math.max(0.2, Math.min(3, initialZoom * scale));
                    
                    // 2æœ¬æŒ‡ãƒ‘ãƒ³
                    const centerX = (touch1.clientX + touch2.clientX) / 2;
                    const centerY = (touch1.clientY + touch2.clientY) / 2;
                    panX = lastPanX + (centerX - panStartX);
                    panY = lastPanY + (centerY - panStartY);
                    
                    applyZoomPan();
                }
            }, { passive: false });
        }
        
        let zoomPanPending = false;
        
        function applyZoomPan() {
            if (zoomPanPending) return;
            zoomPanPending = true;
            requestAnimationFrame(() => {
                zoomPanPending = false;
                applyZoomPanImmediate();
            });
        }
        
        function applyZoomPanImmediate() {
            const container = document.getElementById('gridContainer');
            const grid = document.getElementById('editorGrid');
            
            // ãƒ‘ãƒ³ç¯„å›²ã‚’åˆ¶é™ï¼ˆã‚°ãƒªãƒƒãƒ‰ã®20%ã¯å¸¸ã«è¦‹ãˆã‚‹ã‚ˆã†ã«ï¼‰
            const containerRect = container.getBoundingClientRect();
            const gridWidth = grid.offsetWidth * zoomLevel;
            const gridHeight = grid.offsetHeight * zoomLevel;
            const margin = 50; // æœ€ä½é™è¦‹ãˆã‚‹ç¯„å›²ï¼ˆpxï¼‰
            
            const minX = containerRect.width - gridWidth - margin;
            const maxX = margin;
            const minY = containerRect.height - gridHeight - margin;
            const maxY = margin;
            
            panX = Math.max(minX, Math.min(maxX, panX));
            panY = Math.max(minY, Math.min(maxY, panY));
            
            grid.style.transform = `translate(${panX}px, ${panY}px) scale(${zoomLevel})`;
            grid.style.transformOrigin = '0 0';
            updateZoomDisplay();
        }
        
        function updateZoomDisplay() {
            const zoomDisplay = document.getElementById('zoomLevel');
            if (zoomDisplay) {
                zoomDisplay.textContent = `${Math.round(zoomLevel * 100)}%`;
            }
        }
        
        function zoomIn() {
            zoomLevel = Math.min(3, zoomLevel + 0.2);
            applyZoomPan();
        }
        
        function zoomOut() {
            zoomLevel = Math.max(0.2, zoomLevel - 0.2);
            applyZoomPan();
        }
        
        function resetZoom() {
            zoomLevel = 1;
            panX = 0;
            panY = 0;
            applyZoomPan();
        }
        
        // ============================================================================
        // ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆèª­ã¿è¾¼ã¿/ä¿å­˜
        // ============================================================================
        
        async function loadLayout() {
            const hole = document.getElementById('holeSelect').value;
            const floor = document.getElementById('floorSelect').value;
            if (!hole || !floor) {
                alert('åº—èˆ—ã¨ãƒ•ãƒ­ã‚¢ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            try {
                const response = await fetch(`/api/heatmap/layouts/${encodeURIComponent(hole)}/${encodeURIComponent(floor)}`);
                if (!response.ok) throw new Error('ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
                
                layoutData = await response.json();
                if (!layoutData.floor) layoutData.floor = floor;
                
                selectedCells.clear();
                undoStack = [];
                redoStack = [];
                isDirty = false;
                
                rebuildSpatialIndex();
                renderGrid();
                updateStatus();
                setMessage('ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ');
            } catch (error) {
                console.error('èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                alert('ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
            }
        }
        
        async function saveLayout() {
            if (!layoutData) {
                alert('ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“');
                return;
            }
            const hole = layoutData.hole;
            const floor = layoutData.floor || '1F';
            
            try {
                const response = await fetch(`/api/heatmap/layouts/${encodeURIComponent(hole)}/${encodeURIComponent(floor)}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(layoutData),
                });
                
                if (!response.ok) throw new Error('ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ');
                
                const result = await response.json();
                isDirty = false;
                updateStatus();
                setMessage(`ä¿å­˜ã—ã¾ã—ãŸï¼ˆ${result.cellCount}ã‚»ãƒ«ï¼‰`);
            } catch (error) {
                console.error('ä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
                alert('ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
            }
        }
        
        async function showNewLayoutModal() {
            try {
                const response = await fetch('/api/heatmap/holes');
                const data = await response.json();
                const select = document.getElementById('newLayoutHoleSelect');
                select.innerHTML = '<option value="">åº—èˆ—ã‚’é¸æŠ</option>';
                (data.holes || []).forEach((hole) => {
                    const option = document.createElement('option');
                    option.value = hole;
                    option.textContent = hole;
                    select.appendChild(option);
                });
                document.getElementById('newLayoutFloorInput').value = '1F';
                document.getElementById('newLayoutRowsInput').value = 30;
                document.getElementById('newLayoutColsInput').value = 30;
                openModal('newLayoutModal');
            } catch (error) {
                console.error('åº—èˆ—ä¸€è¦§å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
                alert('åº—èˆ—ä¸€è¦§ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
        }
        
        async function createNewLayout() {
            const hole = document.getElementById('newLayoutHoleSelect').value;
            const floorInput = document.getElementById('newLayoutFloorInput').value.trim();
            const floor = floorInput || '1F';
            const rows = parseInt(document.getElementById('newLayoutRowsInput').value, 10) || 30;
            const cols = parseInt(document.getElementById('newLayoutColsInput').value, 10) || 30;
            
            if (!hole) {
                alert('åº—èˆ—ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            try {
                const response = await fetch(`/api/heatmap/layouts/${encodeURIComponent(hole)}/${encodeURIComponent(floor)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ rows, cols }),
                });
                
                const result = await response.json();
                if (!response.ok) {
                    if (response.status === 409) {
                        alert(`ãƒ•ãƒ­ã‚¢ã€Œ${floor}ã€ã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™ã€‚åˆ¥ã®ãƒ•ãƒ­ã‚¢åã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚`);
                    } else {
                        throw new Error(result.error || 'ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ');
                    }
                    return;
                }
                
                closeModal('newLayoutModal');
                layoutData = result.layout;
                selectedCells.clear();
                undoStack = [];
                redoStack = [];
                isDirty = false;
                
                const holeSelect = document.getElementById('holeSelect');
                const floorSelect = document.getElementById('floorSelect');
                if (holeSelect.querySelector(`option[value="${hole}"]`) === null) {
                    const opt = document.createElement('option');
                    opt.value = hole;
                    opt.textContent = hole;
                    holeSelect.appendChild(opt);
                }
                holeSelect.value = hole;
                await loadFloorList(hole);
                if (floorSelect.querySelector(`option[value="${floor}"]`) === null) {
                    const opt = document.createElement('option');
                    opt.value = floor;
                    opt.textContent = floor;
                    floorSelect.appendChild(opt);
                }
                floorSelect.value = floor;
                
                rebuildSpatialIndex();
                renderGrid();
                updateStatus();
                setMessage('æ–°è¦ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’ä½œæˆã—ã¾ã—ãŸ');
            } catch (error) {
                console.error('ä½œæˆã‚¨ãƒ©ãƒ¼:', error);
                alert('ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
            }
        }
        
        // ============================================================================
        // ã‚°ãƒªãƒƒãƒ‰æç”»
        // ============================================================================
        
        function renderGrid() {
            PerfLogger.measure('renderGrid', () => {
                const grid = document.getElementById('editorGrid');
                grid.innerHTML = '';
                cellElementCache.clear();
                
                if (!layoutData) return;
                
                // ç©ºé–“ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å†æ§‹ç¯‰ï¼ˆundo/redoç­‰ã§layoutDataè‡ªä½“ãŒç½®ãæ›ã‚ã‚‹å ´åˆï¼‰
                rebuildSpatialIndex();
                
                const { rows, cols } = layoutData.grid;
                grid.style.gridTemplateColumns = `repeat(${cols}, var(--cell-size))`;
                grid.style.gridTemplateRows = `repeat(${rows}, var(--cell-size))`;
                
                // DocumentFragmentã§ä¸€æ‹¬è¿½åŠ ï¼ˆDOMæ“ä½œå›æ•°ã‚’å‰Šæ¸›ï¼‰
                const fragment = document.createDocumentFragment();
                
                // ã‚°ãƒªãƒƒãƒ‰ã‚’ç”Ÿæˆ
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const key = `${row}-${col}`;
                        const cellData = cellSpatialIndex.get(key);
                        
                        // ãƒãƒ¼ã‚¸ã•ã‚ŒãŸå­ã‚»ãƒ«ã¯ã‚¹ã‚­ãƒƒãƒ—ï¼ˆè¦ªã‚»ãƒ«ãŒspanã§è¦†ã†ï¼‰
                        if (mergedCellsIndex.has(key)) {
                            continue;
                        }
                        
                        const cellElement = document.createElement('div');
                        cellElement.className = 'editor-cell';
                        cellElement.dataset.row = row;
                        cellElement.dataset.col = col;
                        
                        if (cellData) {
                            renderCellContent(cellElement, cellData);
                            
                            // ãƒãƒ¼ã‚¸ã•ã‚ŒãŸã‚»ãƒ«ï¼ˆè¦ªï¼‰ã¯å¤§ããè¡¨ç¤º
                            if (cellData.mergeRows > 1 || cellData.mergeCols > 1) {
                                const mr = cellData.mergeRows || 1;
                                const mc = cellData.mergeCols || 1;
                                cellElement.style.gridRow = `${row + 1} / span ${mr}`;
                                cellElement.style.gridColumn = `${col + 1} / span ${mc}`;
                                cellElement.classList.add('merged-parent');
                            } else {
                                cellElement.style.gridRow = String(row + 1);
                                cellElement.style.gridColumn = String(col + 1);
                            }
                        } else {
                            cellElement.style.gridRow = String(row + 1);
                            cellElement.style.gridColumn = String(col + 1);
                        }
                        
                        // é¸æŠçŠ¶æ…‹
                        if (selectedCells.has(key)) {
                            cellElement.classList.add('selected');
                        }
                        
                        fragment.appendChild(cellElement);
                        cellElementCache.set(key, cellElement);
                    }
                }
                
                grid.appendChild(fragment);
            });
        }
        
        // å¤‰æ›´ã•ã‚ŒãŸã‚»ãƒ«ã®ã¿DOMã‚’æ›´æ–°ï¼ˆã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ã‚¿ãƒ«æ›´æ–°ï¼‰
        function updateCells(changedKeys) {
            PerfLogger.measure('updateCells', () => {
                changedKeys.forEach(key => {
                    const el = cellElementCache.get(key);
                    if (!el) return;
                    
                    const cellData = cellSpatialIndex.get(key);
                    
                    // ã‚¯ãƒ©ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆselected ã¯åˆ¥é€”ç®¡ç†ï¼‰
                    const isSelected = selectedCells.has(key);
                    el.className = 'editor-cell';
                    el.textContent = '';
                    
                    if (cellData) {
                        renderCellContent(el, cellData);
                    }
                    
                    if (isSelected) {
                        el.classList.add('selected');
                    }
                });
            });
        }
        
        // é¸æŠçŠ¶æ…‹ã®å·®åˆ†æ›´æ–°ï¼ˆclassList ã®ã¿æ“ä½œï¼‰
        function updateSelection(oldSelected, newSelected) {
            PerfLogger.measure('updateSelection', () => {
                oldSelected.forEach(key => {
                    if (!newSelected.has(key)) {
                        const el = cellElementCache.get(key);
                        if (el) el.classList.remove('selected');
                    }
                });
                newSelected.forEach(key => {
                    if (!oldSelected.has(key)) {
                        const el = cellElementCache.get(key);
                        if (el) el.classList.add('selected');
                    }
                });
            });
        }
        
        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰ã‚»ãƒ«è¦ç´ ã‚’å–å¾—ï¼ˆquerySelectorã®ä»£ã‚ã‚Šï¼‰
        function getCellElement(row, col) {
            return cellElementCache.get(`${row}-${col}`);
        }
        
        function renderCellContent(element, cellData) {
            const { type, subtype, number, text, label } = cellData;
            
            if (type === 'machine') {
                element.classList.add('machine');
                element.textContent = number;
            } else if (type === 'structure') {
                element.classList.add('structure', subtype || '');
                element.textContent = label || '';
            } else if (type === 'label') {
                element.classList.add('label');
                element.textContent = text || '';
            }
        }
        
        // ============================================================================
        // ãƒ„ãƒ¼ãƒ«æ“ä½œ
        // ============================================================================
        
        function selectObjectType(subtype) {
            selectedObjectType = subtype;
            document.querySelectorAll('.structure-item').forEach(item => {
                item.classList.toggle('selected', item.dataset.subtype === subtype);
            });
        }
        
        // ============================================================================
        // ã‚»ãƒ«ã‚¯ãƒªãƒƒã‚¯å‡¦ç†
        // ============================================================================
        
        function handleCellClick(e, row, col) {
            const key = `${row}-${col}`;
            const oldSelected = new Set(selectedCells);
            
            // ã‚¯ãƒªãƒƒã‚¯ã§é¸æŠï¼ˆç©ºã§ã‚‚æ—¢å­˜ã§ã‚‚ï¼‰
            if (e.shiftKey) {
                // Shift+ã‚¯ãƒªãƒƒã‚¯ã§è¤‡æ•°é¸æŠ
                if (selectedCells.has(key)) {
                    selectedCells.delete(key);
                } else {
                    selectedCells.add(key);
                }
            } else {
                // å˜ä¸€é¸æŠ
                selectedCells.clear();
                selectedCells.add(key);
            }
            updateSelection(oldSelected, selectedCells);
            updatePropertyPanel();
        }
        
        // é¸æŠã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¿ã‚¤ãƒ—ã‚’ã‚»ãƒ«ã«é…ç½®
        function placeObjectAtCell(row, col) {
            const key = `${row}-${col}`;
            const existingCell = cellSpatialIndex.get(key);
            
            // æ—¢å­˜ã®ã‚»ãƒ«ãŒã‚ã‚‹å ´åˆã¯ä¸Šæ›¸ãç¢ºèª
            if (existingCell) {
                if (existingCell.type === 'machine') {
                    alert('ã“ã®ã‚»ãƒ«ã«ã¯å°ãŒã‚ã‚Šã¾ã™ã€‚å³ãƒ‘ãƒãƒ«ã‹ã‚‰å‰Šé™¤ã—ã¦ãã ã•ã„ã€‚');
                    return;
                }
                // æ§‹é€ ç‰©ã‚„ãƒ©ãƒ™ãƒ«ã¯ä¸Šæ›¸ã
                saveState();
                removeCellFromIndex(existingCell);
                const index = layoutData.cells.indexOf(existingCell);
                if (index >= 0) layoutData.cells.splice(index, 1);
            } else {
                saveState();
            }
            
            if (selectedObjectType === 'machine') {
                // å°ã®å ´åˆã¯ãƒ¢ãƒ¼ãƒ€ãƒ«ã§ç•ªå·å…¥åŠ›
                pendingCellPosition = { row, col };
                document.getElementById('machineNumberInput').value = '';
                openModal('machineModal');
                document.getElementById('machineNumberInput').focus();
            } else if (selectedObjectType === 'label') {
                // ãƒ©ãƒ™ãƒ«ã®å ´åˆã¯ãƒ¢ãƒ¼ãƒ€ãƒ«ã§å…¥åŠ›
                pendingCellPosition = { row, col };
                document.getElementById('labelInput').value = '';
                document.getElementById('labelModalTitle').textContent = 'ãƒ©ãƒ™ãƒ«ã‚’å…¥åŠ›';
                openModal('labelModal');
                document.getElementById('labelInput').focus();
            } else {
                // æ§‹é€ ç‰©ã‚’è¿½åŠ ï¼ˆãƒ©ãƒ™ãƒ«å…¥åŠ›ãªã—ï¼‰
                const newCell = {
                    row, col,
                    type: 'structure',
                    subtype: selectedObjectType,
                };
                layoutData.cells.push(newCell);
                addCellToIndex(newCell);
                markDirty();
                updateCells([key]);
            }
        }
        
        // ç¯„å›²ã«æ§‹é€ ç‰©ã‚’é…ç½®
        // ç¯„å›²é¸æŠã§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é…ç½®
        function placeObjectInRange() {
            if (selectedCells.size < 1) return;
            
            // å°ã¯ç¯„å›²é…ç½®ã§ããªã„
            if (selectedObjectType === 'machine') {
                alert('å°ã¯1ã¤ãšã¤é…ç½®ã—ã¦ãã ã•ã„ã€‚');
                return;
            }
            
            // é¸æŠç¯„å›²ã®å¢ƒç•Œã‚’è¨ˆç®—
            let minRow = Infinity, maxRow = -Infinity;
            let minCol = Infinity, maxCol = -Infinity;
            
            selectedCells.forEach(key => {
                const [row, col] = key.split('-').map(Number);
                minRow = Math.min(minRow, row);
                maxRow = Math.max(maxRow, row);
                minCol = Math.min(minCol, col);
                maxCol = Math.max(maxCol, col);
            });
            
            // ç¯„å›²å†…ã«å°ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            let hasMachine = false;
            for (let r = minRow; r <= maxRow; r++) {
                for (let c = minCol; c <= maxCol; c++) {
                    const cell = cellSpatialIndex.get(`${r}-${c}`);
                    if (cell && cell.type === 'machine') {
                        hasMachine = true;
                        break;
                    }
                }
                if (hasMachine) break;
            }
            
            if (hasMachine) {
                alert('é¸æŠç¯„å›²å†…ã«å°ãŒã‚ã‚Šã¾ã™ã€‚å…ˆã«å‰Šé™¤ã—ã¦ãã ã•ã„ã€‚');
                return;
            }
            
            // ãƒ©ãƒ™ãƒ«å…¥åŠ›ã‚’æ±‚ã‚ã‚‹ï¼ˆç¾åœ¨é¸æŠä¸­ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¿ã‚¤ãƒ—ã‚’ä½¿ç”¨ï¼‰
            pendingRangeSelection = { minRow, maxRow, minCol, maxCol, objectType: selectedObjectType };
            document.getElementById('labelInput').value = '';
            document.getElementById('labelModalTitle').textContent = 
                selectedObjectType === 'label' ? 'ãƒ©ãƒ™ãƒ«ã‚’å…¥åŠ›' : `${getObjectTypeName(selectedObjectType)}ã®ãƒ©ãƒ™ãƒ«ã‚’å…¥åŠ›ï¼ˆä»»æ„ï¼‰`;
            openModal('labelModal');
            document.getElementById('labelInput').focus();
        }
        
        function getObjectTypeName(subtype) {
            const names = {
                machine: 'å°',
                escalator: 'ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚¿ãƒ¼',
                stairs: 'éšæ®µ',
                counter: 'ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼',
                locker: 'ãƒ­ãƒƒã‚«ãƒ¼',
                vending: 'è‡ªè²©æ©Ÿ',
                shelf: 'æ£š',
                pillar: 'æŸ±',
                label: 'ãƒ©ãƒ™ãƒ«',
            };
            return names[subtype] || subtype;
        }
        
        let pendingRangeSelection = null;
        
        
        // ============================================================================
        // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—
        // ============================================================================
        
        function handleCellMouseDown(e, row, col) {
            const key = `${row}-${col}`;
            const cellData = cellSpatialIndex.get(key);
            
            if (cellData && selectedCells.has(key) && !e.shiftKey) {
                // é¸æŠæ¸ˆã¿ã‚»ãƒ«ã‚’ãƒ‰ãƒ©ãƒƒã‚°ç§»å‹•
                isDragging = true;
                dragStartCell = { row, col };
                draggedCells = Array.from(selectedCells).map(k => {
                    return cellSpatialIndex.get(k);
                }).filter(Boolean);
                e.preventDefault();
            } else {
                // ç¯„å›²é¸æŠé–‹å§‹
                isRangeSelecting = true;
                rangeSelectStart = { row, col };
                rangeSelectEnd = { row, col };
                if (!e.shiftKey) {
                    // å‰ã®é¸æŠã‚’è§£é™¤ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä½¿ç”¨ï¼‰
                    selectedCells.forEach(k => {
                        const el = cellElementCache.get(k);
                        if (el) el.classList.remove('selected');
                    });
                    selectedCells.clear();
                }
                selectedCells.add(key);
                // ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‚»ãƒ«ã ã‘é¸æŠï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä½¿ç”¨ï¼‰
                const clickedEl = cellElementCache.get(key);
                if (clickedEl) clickedEl.classList.add('selected');
                e.preventDefault();
            }
        }
        
        // ãƒ‰ãƒ©ãƒƒã‚°æ™‚ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆå¯¾è±¡ã‚»ãƒ«ã‚’è¿½è·¡
        let dragOverCells = new Set();
        
        function handleCellMouseEnter(e, row, col) {
            // ç¯„å›²é¸æŠä¸­
            if (isRangeSelecting) {
                rangeSelectEnd = { row, col };
                updateRangeSelection();
                return;
            }
            
            // ãƒ‰ãƒ©ãƒƒã‚°ç§»å‹•ä¸­
            if (!isDragging) return;
            
            // å‰å›ã®ãƒ‰ãƒ©ãƒƒã‚°ã‚ªãƒ¼ãƒãƒ¼ã‚’è§£é™¤ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä½¿ç”¨ï¼‰
            dragOverCells.forEach(key => {
                const el = cellElementCache.get(key);
                if (el) el.classList.remove('drag-over');
            });
            dragOverCells.clear();
            
            // ãƒ‰ãƒ­ãƒƒãƒ—å…ˆã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä½¿ç”¨ï¼‰
            const offsetRow = row - dragStartCell.row;
            const offsetCol = col - dragStartCell.col;
            
            draggedCells.forEach(cell => {
                const newRow = cell.row + offsetRow;
                const newCol = cell.col + offsetCol;
                const key = `${newRow}-${newCol}`;
                const targetCell = cellElementCache.get(key);
                if (targetCell) {
                    targetCell.classList.add('drag-over');
                    dragOverCells.add(key);
                }
            });
        }
        
        // ã‚¹ãƒ­ãƒƒãƒˆãƒªãƒ³ã‚°ç”¨
        let rangeSelectionPending = false;
        
        function updateRangeSelection() {
            if (!rangeSelectStart || !rangeSelectEnd) return;
            
            // å‰å›ã®æ›´æ–°ãŒã¾ã å‡¦ç†ä¸­ãªã‚‰æ–°ã—ã„ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ã‚­ãƒ¥ãƒ¼ã‚¤ãƒ³ã‚°
            if (rangeSelectionPending) return;
            rangeSelectionPending = true;
            
            requestAnimationFrame(() => {
                rangeSelectionPending = false;
                if (!rangeSelectStart || !rangeSelectEnd) return;
                
                const minRow = Math.min(rangeSelectStart.row, rangeSelectEnd.row);
                const maxRow = Math.max(rangeSelectStart.row, rangeSelectEnd.row);
                const minCol = Math.min(rangeSelectStart.col, rangeSelectEnd.col);
                const maxCol = Math.max(rangeSelectStart.col, rangeSelectEnd.col);
                
                // å‰ã®é¸æŠã‚’è§£é™¤ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä½¿ç”¨ï¼‰
                selectedCells.forEach(key => {
                    const el = cellElementCache.get(key);
                    if (el) el.classList.remove('selected');
                });
                
                selectedCells.clear();
                
                // æ–°ã—ã„é¸æŠã‚’è¿½åŠ ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä½¿ç”¨ï¼‰
                for (let r = minRow; r <= maxRow; r++) {
                    for (let c = minCol; c <= maxCol; c++) {
                        const key = `${r}-${c}`;
                        selectedCells.add(key);
                        const el = cellElementCache.get(key);
                        if (el) el.classList.add('selected');
                    }
                }
            });
        }
        
        function handleCellMouseUp(e, row, col) {
            // ç¯„å›²é¸æŠçµ‚äº†
            if (isRangeSelecting) {
                isRangeSelecting = false;
                rangeSelectStart = null;
                rangeSelectEnd = null;
                
                updatePropertyPanel();
                return;
            }
            
            if (!isDragging) return;
            
            const offsetRow = row - dragStartCell.row;
            const offsetCol = col - dragStartCell.col;
            
            if (offsetRow !== 0 || offsetCol !== 0) {
                // ç§»å‹•å…ˆãŒæœ‰åŠ¹ã‹ãƒã‚§ãƒƒã‚¯
                let canMove = true;
                const newPositions = draggedCells.map(cell => ({
                    row: cell.row + offsetRow,
                    col: cell.col + offsetCol,
                }));
                
                newPositions.forEach(pos => {
                    if (pos.row < 0 || pos.row >= layoutData.grid.rows ||
                        pos.col < 0 || pos.col >= layoutData.grid.cols) {
                        canMove = false;
                    }
                    
                    // ç§»å‹•å…ˆã«ä»–ã®ã‚»ãƒ«ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆè‡ªåˆ†è‡ªèº«ã¯é™¤ãï¼‰
                    const existingCell = cellSpatialIndex.get(`${pos.row}-${pos.col}`);
                    if (existingCell && !draggedCells.includes(existingCell)) {
                        canMove = false;
                    }
                });
                
                if (canMove) {
                    saveState();
                    const oldKeys = draggedCells.map(cell => `${cell.row}-${cell.col}`);
                    
                    // ç©ºé–“ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‹ã‚‰æ—§ä½ç½®ã‚’å‰Šé™¤
                    draggedCells.forEach(cell => removeCellFromIndex(cell));
                    
                    // ã‚»ãƒ«ã‚’ç§»å‹•
                    draggedCells.forEach((cell, i) => {
                        cell.row = newPositions[i].row;
                        cell.col = newPositions[i].col;
                    });
                    
                    // ç©ºé–“ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«æ–°ä½ç½®ã‚’è¿½åŠ 
                    draggedCells.forEach(cell => addCellToIndex(cell));
                    
                    // é¸æŠçŠ¶æ…‹ã‚’æ›´æ–°
                    selectedCells.clear();
                    newPositions.forEach(pos => {
                        selectedCells.add(`${pos.row}-${pos.col}`);
                    });
                    
                    markDirty();
                    
                    // ãƒãƒ¼ã‚¸ã•ã‚ŒãŸã‚»ãƒ«ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                    const hasMerges = draggedCells.some(c => (c.mergeRows || 1) > 1 || (c.mergeCols || 1) > 1);
                    
                    // ãƒ‰ãƒ©ãƒƒã‚°ã‚ªãƒ¼ãƒãƒ¼ã‚’è§£é™¤
                    dragOverCells.forEach(key => {
                        const el = cellElementCache.get(key);
                        if (el) el.classList.remove('drag-over');
                    });
                    dragOverCells.clear();
                    
                    isDragging = false;
                    dragStartCell = null;
                    draggedCells = [];
                    
                    if (hasMerges) {
                        renderGrid(); // ãƒãƒ¼ã‚¸ã‚»ãƒ«ã®ç§»å‹•ã¯ãƒ•ãƒ«ãƒªãƒ“ãƒ«ãƒ‰
                    } else {
                        const newKeys = newPositions.map(p => `${p.row}-${p.col}`);
                        updateCells([...oldKeys, ...newKeys]);
                    }
                    return;
                }
            }
            
            // ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†ï¼ˆç§»å‹•ãªã— or ç§»å‹•ä¸å¯ï¼‰
            isDragging = false;
            dragStartCell = null;
            draggedCells = [];
            
            // ãƒ‰ãƒ©ãƒƒã‚°ã‚ªãƒ¼ãƒãƒ¼ã‚’è§£é™¤ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä½¿ç”¨ï¼‰
            dragOverCells.forEach(key => {
                const el = cellElementCache.get(key);
                if (el) el.classList.remove('drag-over');
            });
            dragOverCells.clear();
        }
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã®mouseupï¼ˆã‚°ãƒªãƒƒãƒ‰å¤–ã§ã®ãƒã‚¦ã‚¹ã‚¢ãƒƒãƒ—å¯¾å¿œï¼‰
        document.addEventListener('mouseup', () => {
            if (isRangeSelecting) {
                isRangeSelecting = false;
                rangeSelectStart = null;
                rangeSelectEnd = null;
                updatePropertyPanel();
            }
        });
        
        // ============================================================================
        // ãƒ¢ãƒ¼ãƒ€ãƒ«
        // ============================================================================
        
        let pendingCellPosition = null;
        
        function openModal(id) {
            document.getElementById(id).classList.add('active');
        }
        
        function closeModal(id) {
            document.getElementById(id).classList.remove('active');
            pendingCellPosition = null;
        }
        
        function addMachineFromModal() {
            const numberInput = document.getElementById('machineNumberInput');
            const number = parseInt(numberInput.value);
            
            if (!number || number < 100 || number > 9999) {
                alert('æœ‰åŠ¹ãªå°ç•ªå·ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆ100-9999ï¼‰');
                return;
            }
            
            saveState();
            const newCell = {
                row: pendingCellPosition.row,
                col: pendingCellPosition.col,
                type: 'machine',
                number,
            };
            layoutData.cells.push(newCell);
            addCellToIndex(newCell);
            
            const key = `${newCell.row}-${newCell.col}`;
            markDirty();
            closeModal('machineModal');
            updateCells([key]);
        }
        
        function addLabelFromModal() {
            const labelInput = document.getElementById('labelInput');
            const text = labelInput.value.trim();
            
            // ç¯„å›²é¸æŠã®å ´åˆ
            if (pendingRangeSelection) {
                const { minRow, maxRow, minCol, maxCol, objectType } = pendingRangeSelection;
                const mergeRows = maxRow - minRow + 1;
                const mergeCols = maxCol - minCol + 1;
                
                saveState();
                
                // ç¯„å›²å†…ã®æ—¢å­˜ã‚»ãƒ«ã‚’å‰Šé™¤
                for (let r = minRow; r <= maxRow; r++) {
                    for (let c = minCol; c <= maxCol; c++) {
                        const existing = cellSpatialIndex.get(`${r}-${c}`);
                        if (existing) {
                            removeCellFromIndex(existing);
                            const index = layoutData.cells.indexOf(existing);
                            if (index >= 0) layoutData.cells.splice(index, 1);
                        }
                    }
                }
                
                // çµåˆã•ã‚ŒãŸæ§‹é€ ç‰©ã‚’è¿½åŠ ï¼ˆå·¦ä¸Šã®ã‚»ãƒ«ã«é…ç½®ï¼‰
                let newCell;
                if (objectType === 'label') {
                    newCell = {
                        row: minRow,
                        col: minCol,
                        type: 'label',
                        text: text || '',
                        mergeRows,
                        mergeCols,
                    };
                } else {
                    newCell = {
                        row: minRow,
                        col: minCol,
                        type: 'structure',
                        subtype: objectType,
                        label: text || '',
                        mergeRows,
                        mergeCols,
                    };
                }
                layoutData.cells.push(newCell);
                addCellToIndex(newCell);
                
                pendingRangeSelection = null;
                selectedCells.clear();
                markDirty();
                closeModal('labelModal');
                document.getElementById('labelModalTitle').textContent = 'ãƒ©ãƒ™ãƒ«ã‚’å…¥åŠ›';
                renderGrid(); // ãƒãƒ¼ã‚¸ã‚»ãƒ«ã®è¿½åŠ ã¯ãƒ•ãƒ«ãƒªãƒ“ãƒ«ãƒ‰
                return;
            }
            
            // å˜ä¸€ã‚»ãƒ«ã®å ´åˆï¼ˆãƒ©ãƒ™ãƒ«ã‚¿ã‚¤ãƒ—ã®æ™‚ã ã‘ãƒ†ã‚­ã‚¹ãƒˆå¿…é ˆï¼‰
            if (selectedObjectType === 'label' && !text) {
                alert('ãƒ©ãƒ™ãƒ«ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            saveState();
            const labelCell = {
                row: pendingCellPosition.row,
                col: pendingCellPosition.col,
                type: 'label',
                text,
            };
            layoutData.cells.push(labelCell);
            addCellToIndex(labelCell);
            
            const labelKey = `${labelCell.row}-${labelCell.col}`;
            markDirty();
            closeModal('labelModal');
            updateCells([labelKey]);
        }
        
        function showGridSettings() {
            if (!layoutData) return;
            
            document.getElementById('gridRowsInput').value = layoutData.grid.rows;
            document.getElementById('gridColsInput').value = layoutData.grid.cols;
            openModal('gridModal');
        }
        
        function applyGridSettings() {
            const newRows = parseInt(document.getElementById('gridRowsInput').value);
            const newCols = parseInt(document.getElementById('gridColsInput').value);
            const rowExpand = document.querySelector('input[name="rowExpand"]:checked').value;
            const colExpand = document.querySelector('input[name="colExpand"]:checked').value;
            
            if (!newRows || !newCols || newRows < 1 || newCols < 1) {
                alert('æœ‰åŠ¹ãªå€¤ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            saveState();
            
            const oldRows = layoutData.grid.rows;
            const oldCols = layoutData.grid.cols;
            const rowDiff = newRows - oldRows;
            const colDiff = newCols - oldCols;
            
            // ä¸Šã¾ãŸã¯å·¦ã‹ã‚‰æ‹¡å¼µ/ç¸®å°ã™ã‚‹å ´åˆã€æ—¢å­˜ã®ã‚»ãƒ«ã‚’ã‚·ãƒ•ãƒˆ
            if (rowExpand === 'top' && rowDiff !== 0) {
                layoutData.cells.forEach(cell => {
                    cell.row += rowDiff;
                });
            }
            
            if (colExpand === 'left' && colDiff !== 0) {
                layoutData.cells.forEach(cell => {
                    cell.col += colDiff;
                });
            }
            
            layoutData.grid.rows = newRows;
            layoutData.grid.cols = newCols;
            
            // ç¯„å›²å¤–ã®ã‚»ãƒ«ã‚’å‰Šé™¤ï¼ˆã‚·ãƒ•ãƒˆå¾Œï¼‰
            layoutData.cells = layoutData.cells.filter(c => 
                c.row >= 0 && c.row < newRows && c.col >= 0 && c.col < newCols
            );
            
            markDirty();
            closeModal('gridModal');
            renderGrid();
            updateStatus();
        }
        
        // ============================================================================
        // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ‘ãƒãƒ«
        // ============================================================================
        
        function updatePropertyPanel() {
            const content = document.getElementById('propertyContent');
            
            if (selectedCells.size === 0) {
                content.innerHTML = '<div style="color: var(--text-secondary); font-size: 12px;">ã‚»ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„</div>';
                return;
            }
            
            if (selectedCells.size === 1) {
                const key = Array.from(selectedCells)[0];
                const [row, col] = key.split('-').map(Number);
                const cellData = cellSpatialIndex.get(key);
                
                if (cellData) {
                    content.innerHTML = renderCellProperties(cellData, row, col);
                    setupPropertyEvents(cellData);
                } else {
                    // ç©ºã®ã‚»ãƒ« - ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé…ç½®ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
                    content.innerHTML = `
                        <div class="property-row">
                            <span class="property-label">ä½ç½®</span>
                            <span class="property-value">è¡Œ ${row}, åˆ— ${col}</span>
                        </div>
                        <div style="color: var(--text-secondary); font-size: 12px; margin-bottom: 12px;">ç©ºã®ã‚»ãƒ«</div>
                        <button class="property-btn" id="placeObjectBtn" style="background-color: var(--accent-blue); border-color: var(--accent-blue); color: white;">
                            ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é…ç½®
                        </button>
                    `;
                    document.getElementById('placeObjectBtn')?.addEventListener('click', placeObjectInRange);
                }
            } else {
                // ç¯„å›²é¸æŠæ™‚
                const keys = Array.from(selectedCells);
                const rows = keys.map(k => parseInt(k.split('-')[0]));
                const cols = keys.map(k => parseInt(k.split('-')[1]));
                const minRow = Math.min(...rows);
                const maxRow = Math.max(...rows);
                const minCol = Math.min(...cols);
                const maxCol = Math.max(...cols);
                
                content.innerHTML = `
                    <div class="property-row">
                        <span class="property-label">é¸æŠç¯„å›²</span>
                        <span class="property-value">${maxRow - minRow + 1}è¡Œ Ã— ${maxCol - minCol + 1}åˆ—</span>
                    </div>
                    <div class="property-row">
                        <span class="property-label">ã‚»ãƒ«æ•°</span>
                        <span class="property-value">${selectedCells.size}ã‚»ãƒ«</span>
                    </div>
                    <button class="property-btn" id="placeObjectBtn" style="background-color: var(--accent-blue); border-color: var(--accent-blue); color: white; margin-bottom: 8px;">
                        ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é…ç½®
                    </button>
                    <button class="property-btn danger" id="deleteSelectedBtn">é¸æŠã‚’å‰Šé™¤</button>
                `;
                document.getElementById('deleteSelectedBtn')?.addEventListener('click', deleteSelected);
                document.getElementById('placeObjectBtn')?.addEventListener('click', placeObjectInRange);
            }
        }
        
        function renderCellProperties(cellData, row, col) {
            let html = `
                <div class="property-row">
                    <span class="property-label">ä½ç½®</span>
                    <span class="property-value">è¡Œ ${row}, åˆ— ${col}</span>
                </div>
            `;
            
            if (cellData.type === 'machine') {
                html += `
                    <div class="property-row">
                        <label class="property-label">å°ç•ªå·</label>
                        <input type="number" id="propMachineNumber" class="property-input" value="${cellData.number}">
                    </div>
                `;
            } else if (cellData.type === 'structure') {
                html += `
                    <div class="property-row">
                        <span class="property-label">ã‚¿ã‚¤ãƒ—</span>
                        <span class="property-value">${getObjectTypeName(cellData.subtype)}</span>
                    </div>
                    <div class="property-row">
                        <label class="property-label">ãƒ©ãƒ™ãƒ«</label>
                        <input type="text" id="propLabel" class="property-input" value="${cellData.label || ''}">
                    </div>
                    <div class="property-row">
                        <label class="property-label">ã‚µã‚¤ã‚º</label>
                        <div style="display: flex; gap: 4px; align-items: center;">
                            <input type="number" id="propMergeRows" class="property-input" style="width: 50px;" value="${cellData.mergeRows || 1}" min="1">
                            <span>è¡Œ</span>
                            <span style="margin: 0 4px;">Ã—</span>
                            <input type="number" id="propMergeCols" class="property-input" style="width: 50px;" value="${cellData.mergeCols || 1}" min="1">
                            <span>åˆ—</span>
                        </div>
                    </div>
                `;
            } else if (cellData.type === 'label') {
                html += `
                    <div class="property-row">
                        <label class="property-label">ãƒ†ã‚­ã‚¹ãƒˆ</label>
                        <input type="text" id="propText" class="property-input" value="${cellData.text || ''}">
                    </div>
                    <div class="property-row">
                        <label class="property-label">ã‚µã‚¤ã‚º</label>
                        <div style="display: flex; gap: 4px; align-items: center;">
                            <input type="number" id="propMergeRows" class="property-input" style="width: 50px;" value="${cellData.mergeRows || 1}" min="1">
                            <span>è¡Œ</span>
                            <span style="margin: 0 4px;">Ã—</span>
                            <input type="number" id="propMergeCols" class="property-input" style="width: 50px;" value="${cellData.mergeCols || 1}" min="1">
                            <span>åˆ—</span>
                        </div>
                    </div>
                `;
            }
            
            html += '<button class="property-btn danger" id="deleteCellBtn">å‰Šé™¤</button>';
            
            return html;
        }
        
        function setupPropertyEvents(cellData) {
            document.getElementById('deleteCellBtn')?.addEventListener('click', () => {
                saveState();
                const key = `${cellData.row}-${cellData.col}`;
                const needsFullRebuild = (cellData.mergeRows || 1) > 1 || (cellData.mergeCols || 1) > 1;
                removeCellFromIndex(cellData);
                const index = layoutData.cells.indexOf(cellData);
                if (index >= 0) {
                    layoutData.cells.splice(index, 1);
                    selectedCells.clear();
                    markDirty();
                    if (needsFullRebuild) {
                        renderGrid(); // ãƒãƒ¼ã‚¸ã‚»ãƒ«å‰Šé™¤ã¯ãƒ•ãƒ«ãƒªãƒ“ãƒ«ãƒ‰
                    } else {
                        updateCells([key]);
                    }
                    updatePropertyPanel();
                }
            });
            
            // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£å¤‰æ›´ã¯ãƒ‡ãƒã‚¦ãƒ³ã‚¹ã§ä¿å­˜ï¼ˆé€£ç¶šå…¥åŠ›å¯¾å¿œï¼‰
            document.getElementById('propMachineNumber')?.addEventListener('change', (e) => {
                saveStateDebounced();
                cellData.number = parseInt(e.target.value);
                markDirty();
                updateCells([`${cellData.row}-${cellData.col}`]);
            });
            
            document.getElementById('propLabel')?.addEventListener('change', (e) => {
                saveStateDebounced();
                cellData.label = e.target.value;
                markDirty();
                updateCells([`${cellData.row}-${cellData.col}`]);
            });
            
            document.getElementById('propText')?.addEventListener('change', (e) => {
                saveStateDebounced();
                cellData.text = e.target.value;
                markDirty();
                updateCells([`${cellData.row}-${cellData.col}`]);
            });
            
            // æ§‹é€ ç‰©ã‚µã‚¤ã‚ºå¤‰æ›´ï¼ˆãƒãƒ¼ã‚¸å¤‰æ›´ã¯ãƒ•ãƒ«ãƒªãƒ“ãƒ«ãƒ‰ãŒå¿…è¦ï¼‰
            document.getElementById('propMergeRows')?.addEventListener('change', (e) => {
                const newRows = parseInt(e.target.value) || 1;
                if (newRows < 1) return;
                
                const row = cellData.row;
                const col = cellData.col;
                const newMergeCols = cellData.mergeCols || 1;
                
                if (checkOverlap(row, col, newRows, newMergeCols, cellData)) {
                    alert('ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨é‡è¤‡ã—ã¾ã™');
                    e.target.value = cellData.mergeRows || 1;
                    return;
                }
                
                saveState();
                // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‹ã‚‰æ—§çŠ¶æ…‹ã‚’å‰Šé™¤ã—ã¦ã‹ã‚‰å¤‰æ›´
                removeCellFromIndex(cellData);
                cellData.mergeRows = newRows;
                if (cellData.mergeRows === 1 && (cellData.mergeCols || 1) === 1) {
                    delete cellData.mergeRows;
                    delete cellData.mergeCols;
                }
                addCellToIndex(cellData);
                markDirty();
                renderGrid(); // ãƒãƒ¼ã‚¸å¤‰æ›´ã¯ãƒ•ãƒ«ãƒªãƒ“ãƒ«ãƒ‰
                updatePropertyPanel();
            });
            
            document.getElementById('propMergeCols')?.addEventListener('change', (e) => {
                const newCols = parseInt(e.target.value) || 1;
                if (newCols < 1) return;
                
                const row = cellData.row;
                const col = cellData.col;
                const newMergeRows = cellData.mergeRows || 1;
                
                if (checkOverlap(row, col, newMergeRows, newCols, cellData)) {
                    alert('ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨é‡è¤‡ã—ã¾ã™');
                    e.target.value = cellData.mergeCols || 1;
                    return;
                }
                
                saveState();
                removeCellFromIndex(cellData);
                cellData.mergeCols = newCols;
                if ((cellData.mergeRows || 1) === 1 && cellData.mergeCols === 1) {
                    delete cellData.mergeRows;
                    delete cellData.mergeCols;
                }
                addCellToIndex(cellData);
                markDirty();
                renderGrid(); // ãƒãƒ¼ã‚¸å¤‰æ›´ã¯ãƒ•ãƒ«ãƒªãƒ“ãƒ«ãƒ‰
                updatePropertyPanel();
            });
        }
        
        // é‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼ˆè‡ªèº«ã‚’é™¤ãï¼‰ - ç©ºé–“ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ O(mergeArea) ã«æœ€é©åŒ–
        function checkOverlap(row, col, mergeRows, mergeCols, excludeCell) {
            const excludeRowEnd = excludeCell ? excludeCell.row + (excludeCell.mergeRows || 1) : -1;
            const excludeColEnd = excludeCell ? excludeCell.col + (excludeCell.mergeCols || 1) : -1;
            
            for (let r = row; r < row + mergeRows; r++) {
                for (let c = col; c < col + mergeCols; c++) {
                    const key = `${r}-${c}`;
                    
                    // ã“ã®ä½ç½®ã«ã‚»ãƒ«ãŒã‚ã‚‹ã‹ï¼ˆç›´æ¥é…ç½®ï¼‰
                    const existing = cellSpatialIndex.get(key);
                    if (existing && existing !== excludeCell) return true;
                    
                    // ã“ã®ä½ç½®ãŒãƒãƒ¼ã‚¸ã•ã‚ŒãŸå­ã‚»ãƒ«ã‹
                    if (mergedCellsIndex.has(key)) {
                        // excludeCell ã®ãƒãƒ¼ã‚¸ç¯„å›²å†…ãªã‚‰ç„¡è¦–
                        if (excludeCell &&
                            r >= excludeCell.row && r < excludeRowEnd &&
                            c >= excludeCell.col && c < excludeColEnd) {
                            continue;
                        }
                        return true;
                    }
                }
            }
            return false;
        }
        
        function deleteSelected() {
            if (selectedCells.size === 0) return;
            
            saveState();
            const changedKeys = [];
            let needsFullRebuild = false;
            
            selectedCells.forEach(key => {
                const cellData = cellSpatialIndex.get(key);
                if (cellData) {
                    if ((cellData.mergeRows || 1) > 1 || (cellData.mergeCols || 1) > 1) {
                        needsFullRebuild = true;
                    }
                    removeCellFromIndex(cellData);
                    const index = layoutData.cells.indexOf(cellData);
                    if (index >= 0) {
                        layoutData.cells.splice(index, 1);
                    }
                    changedKeys.push(key);
                }
            });
            
            selectedCells.clear();
            markDirty();
            
            if (needsFullRebuild) {
                renderGrid(); // ãƒãƒ¼ã‚¸ã‚»ãƒ«å‰Šé™¤ã¯ãƒ•ãƒ«ãƒªãƒ“ãƒ«ãƒ‰
            } else {
                updateCells(changedKeys);
            }
            updatePropertyPanel();
        }
        
        // ============================================================================
        // Undo/Redo
        // ============================================================================
        
        // å³æ™‚ä¿å­˜ï¼ˆã‚¯ãƒªãƒƒã‚¯æ“ä½œãªã©ï¼‰
        function saveState() {
            PerfLogger.measure('saveState', () => {
                // ãƒ‡ãƒã‚¦ãƒ³ã‚¹ä¸­ã®ã‚¿ã‚¤ãƒãƒ¼ãŒã‚ã‚Œã°ã‚­ãƒ£ãƒ³ã‚»ãƒ«
                if (saveStateTimer) {
                    clearTimeout(saveStateTimer);
                    saveStateTimer = null;
                }
                undoStack.push(structuredClone(layoutData));
                redoStack = [];
                
                // ã‚¹ã‚¿ãƒƒã‚¯ã‚µã‚¤ã‚ºã‚’åˆ¶é™
                if (undoStack.length > 50) {
                    undoStack.shift();
                }
            });
        }
        
        // ãƒ‡ãƒã‚¦ãƒ³ã‚¹ä¿å­˜ï¼ˆãƒ—ãƒ­ãƒ‘ãƒ†ã‚£å¤‰æ›´ãªã©é€£ç¶šå…¥åŠ›æ™‚ï¼‰
        let saveStateTimer = null;
        function saveStateDebounced() {
            if (saveStateTimer) clearTimeout(saveStateTimer);
            saveStateTimer = setTimeout(() => {
                saveStateTimer = null;
                undoStack.push(structuredClone(layoutData));
                redoStack = [];
                if (undoStack.length > 50) undoStack.shift();
            }, 300);
        }
        
        function undo() {
            if (undoStack.length === 0) return;
            
            redoStack.push(structuredClone(layoutData));
            layoutData = undoStack.pop();
            selectedCells.clear();
            markDirty();
            renderGrid(); // undo ã¯ãƒ•ãƒ«ãƒªãƒ“ãƒ«ãƒ‰ï¼ˆæ§‹é€ ãŒå¤§ããå¤‰ã‚ã‚Šã†ã‚‹ï¼‰
            updatePropertyPanel();
        }
        
        function redo() {
            if (redoStack.length === 0) return;
            
            undoStack.push(structuredClone(layoutData));
            layoutData = redoStack.pop();
            selectedCells.clear();
            markDirty();
            renderGrid(); // redo ã¯ãƒ•ãƒ«ãƒªãƒ“ãƒ«ãƒ‰
            updatePropertyPanel();
        }
        
        // ============================================================================
        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
        // ============================================================================
        
        function handleKeydown(e) {
            // ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒé–‹ã„ã¦ã„ã‚‹å ´åˆã¯ç„¡è¦–
            if (document.querySelector('.modal-overlay.active')) return;
            
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 's') {
                    e.preventDefault();
                    saveLayout();
                } else if (e.key === 'z') {
                    e.preventDefault();
                    if (e.shiftKey) {
                        redo();
                    } else {
                        undo();
                    }
                }
            } else {
                switch (e.key) {
                    case 'Delete':
                    case 'Backspace':
                        if (selectedCells.size > 0) {
                            e.preventDefault();
                            deleteSelected();
                        }
                        break;
                    case 'Escape':
                        {
                            const oldSel = new Set(selectedCells);
                            selectedCells.clear();
                            updateSelection(oldSel, selectedCells);
                            updatePropertyPanel();
                        }
                        break;
                }
            }
        }
        
        // ============================================================================
        // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
        // ============================================================================
        
        function markDirty() {
            isDirty = true;
            updateStatus();
        }
        
        function updateStatus() {
            if (!layoutData) {
                document.getElementById('statusHole').textContent = 'åº—èˆ—: æœªé¸æŠ';
                document.getElementById('statusFloor').textContent = 'ãƒ•ãƒ­ã‚¢: -';
                document.getElementById('statusGrid').textContent = 'ã‚°ãƒªãƒƒãƒ‰: -';
                document.getElementById('statusCells').textContent = 'ã‚»ãƒ«æ•°: -';
                return;
            }
            
            document.getElementById('statusHole').textContent = `åº—èˆ—: ${layoutData.hole}`;
            document.getElementById('statusFloor').textContent = `ãƒ•ãƒ­ã‚¢: ${layoutData.floor || '1F'}`;
            document.getElementById('statusGrid').textContent = `ã‚°ãƒªãƒƒãƒ‰: ${layoutData.grid.rows}Ã—${layoutData.grid.cols}`;
            document.getElementById('statusCells').textContent = `ã‚»ãƒ«æ•°: ${layoutData.cells.length}`;
            
            if (isDirty) {
                document.getElementById('statusMessage').textContent = 'æœªä¿å­˜ã®å¤‰æ›´ãŒã‚ã‚Šã¾ã™';
            }
        }
        
        function setMessage(msg) {
            document.getElementById('statusMessage').textContent = msg;
        }
        
        // ============================================================================
        // åˆæœŸåŒ–å®Ÿè¡Œ
        // ============================================================================
        init();
    </script>
</body>
</html>
