<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>失敗管理・手動補正 - Yobun</title>
    <script src="/js/status-header.js"></script>
    <script src="/js/config.js"></script>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --border-color: #30363d;
            --text-primary: #c9d1d9;
            --text-secondary: #8b949e;
            --accent-green: #3fb950;
            --accent-yellow: #d29922;
            --accent-red: #f85149;
            --accent-blue: #58a6ff;
            --accent-purple: #a371f7;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.5;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border-color);
        }
        
        h1 {
            font-size: 24px;
            font-weight: 600;
        }
        
        h2 {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 16px;
            color: var(--text-secondary);
        }
        
        /* タブナビゲーション */
        .tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 24px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .tab {
            padding: 12px 20px;
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            border-bottom: 2px solid transparent;
            margin-bottom: -1px;
        }
        
        .tab:hover {
            color: var(--text-primary);
        }
        
        .tab.active {
            color: var(--accent-blue);
            border-bottom-color: var(--accent-blue);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* 共通コンポーネント */
        .section {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 24px;
        }
        
        .controls {
            display: flex;
            gap: 16px;
            margin-bottom: 16px;
            flex-wrap: wrap;
            align-items: flex-end;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        label {
            color: var(--text-secondary);
            font-size: 12px;
        }
        
        input[type="date"], input[type="text"], select, textarea {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            padding: 8px 12px;
            font-size: 14px;
        }
        
        select[multiple] {
            padding: 4px;
        }
        
        select[multiple] option {
            padding: 4px 8px;
            border-radius: 4px;
            margin: 1px 0;
        }
        
        select[multiple] option:checked {
            background-color: var(--accent-blue);
            color: white;
        }
        
        textarea {
            font-family: monospace;
            resize: vertical;
            min-height: 120px;
        }
        
        button {
            background-color: var(--accent-blue);
            border: none;
            border-radius: 6px;
            color: white;
            padding: 8px 16px;
            font-size: 14px;
            cursor: pointer;
            font-weight: 500;
        }
        
        button:hover {
            opacity: 0.9;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        button.btn-danger {
            background-color: var(--accent-red);
        }
        
        button.btn-warning {
            background-color: var(--accent-yellow);
            color: #000;
        }
        
        button.btn-secondary {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
        }
        
        button.btn-success {
            background-color: var(--accent-green);
        }
        
        /* サマリーカード */
        .summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 16px;
            margin-bottom: 24px;
        }
        
        .summary-card {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
        }
        
        .summary-card h3 {
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 8px;
        }
        
        .summary-card .value {
            font-size: 24px;
            font-weight: 600;
        }
        
        .summary-card.warning .value { color: var(--accent-yellow); }
        .summary-card.success .value { color: var(--accent-green); }
        .summary-card.error .value { color: var(--accent-red); }
        
        /* テーブル */
        .table-container {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: auto;
            max-height: 500px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        
        th, td {
            padding: 12px 16px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }
        
        th {
            background-color: var(--bg-tertiary);
            font-weight: 600;
            color: var(--text-secondary);
            position: sticky;
            top: 0;
        }
        
        th.sortable {
            cursor: pointer;
            user-select: none;
        }
        
        th.sortable:hover {
            background-color: var(--bg-primary);
        }
        
        th.sortable::after {
            content: '';
            display: inline-block;
            margin-left: 6px;
            opacity: 0.3;
        }
        
        th.sortable.asc::after {
            content: '▲';
            opacity: 1;
        }
        
        th.sortable.desc::after {
            content: '▼';
            opacity: 1;
        }
        
        tr:hover {
            background-color: var(--bg-tertiary);
        }
        
        /* チェックボックス */
        th.checkbox-col, td.checkbox-col {
            width: 40px;
            text-align: center;
            padding: 12px 8px;
        }
        
        input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        
        .bulk-actions {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-top: 12px;
            padding: 12px;
            background-color: var(--bg-tertiary);
            border-radius: 6px;
        }
        
        .bulk-actions.hidden {
            display: none;
        }
        
        .selected-count {
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        /* ステータスバッジ */
        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }
        
        .badge-pending {
            background-color: rgba(210, 153, 34, 0.2);
            color: var(--accent-yellow);
        }
        
        .badge-resolved {
            background-color: rgba(63, 185, 80, 0.2);
            color: var(--accent-green);
        }
        
        .badge-ignored {
            background-color: rgba(139, 148, 158, 0.2);
            color: var(--text-secondary);
        }
        
        .badge-cloudflare {
            background-color: rgba(248, 81, 73, 0.2);
            color: var(--accent-red);
        }
        
        .badge-timeout {
            background-color: rgba(163, 113, 247, 0.2);
            color: var(--accent-purple);
        }
        
        /* 補正入力エリア */
        .correction-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
        }
        
        @media (max-width: 1200px) {
            .correction-layout {
                grid-template-columns: 1fr;
            }
        }
        
        /* プレビューテーブル */
        .preview-table {
            max-height: 300px;
            overflow: auto;
        }
        
        .preview-table table {
            font-size: 13px;
        }
        
        .preview-table input {
            width: 80px;
            padding: 4px 8px;
            font-size: 13px;
        }
        
        /* メッセージ */
        .message {
            padding: 16px;
            border-radius: 6px;
            margin-bottom: 16px;
        }
        
        .message.error {
            background-color: rgba(248, 81, 73, 0.1);
            border: 1px solid var(--accent-red);
            color: var(--accent-red);
        }
        
        .message.success {
            background-color: rgba(63, 185, 80, 0.1);
            border: 1px solid var(--accent-green);
            color: var(--accent-green);
        }
        
        /* 選択状態 */
        .selected-failure {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--accent-blue);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        .selected-failure h3 {
            font-size: 14px;
            margin-bottom: 8px;
        }
        
        .selected-failure .info {
            display: flex;
            gap: 24px;
            flex-wrap: wrap;
            font-size: 14px;
        }
        
        .selected-failure .info span {
            color: var(--text-secondary);
        }
        
        .selected-actions {
            display: flex;
            gap: 8px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border-color);
        }
        
        .selected-actions button {
            padding: 6px 12px;
            font-size: 13px;
        }
        
        /* アクションボタン群 */
        .action-buttons {
            display: flex;
            gap: 8px;
            margin-top: 16px;
            justify-content: flex-end;
            flex-wrap: wrap;
        }
        
        .action-buttons button {
            padding: 8px 16px;
            font-size: 13px;
        }
        
        .action-buttons button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .hidden {
            display: none !important;
        }
        
        /* ローディングオーバーレイ */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(13, 17, 23, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }
        
        .loading-overlay.hidden {
            display: none !important;
        }
        
        .loading-spinner {
            width: 48px;
            height: 48px;
            border: 4px solid var(--border-color);
            border-top-color: var(--accent-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-text {
            margin-top: 16px;
            color: var(--text-primary);
            font-size: 14px;
        }
    </style>
</head>
<body>
    <!-- ローディングオーバーレイ -->
    <div id="loadingOverlay" class="loading-overlay hidden">
        <div class="loading-spinner"></div>
        <div class="loading-text" id="loadingText">処理中...</div>
    </div>
    <div class="container">
        <header>
            <h1>失敗管理・手動補正</h1>
            <nav style="display: flex; gap: 16px;">
                <a href="/dashboard" style="color: var(--accent-blue); text-decoration: none;">ダッシュボード</a>
                <a href="/schedule" style="color: var(--accent-blue); text-decoration: none;">スケジュール</a>
                <a href="/datamart" style="color: var(--accent-blue); text-decoration: none;">データマート</a>
            </nav>
        </header>
        
        <!-- タブナビゲーション -->
        <div class="tabs">
            <button class="tab active" data-tab="failures-list">失敗一覧</button>
            <button class="tab" data-tab="correction-input">補正入力</button>
            <button class="tab" data-tab="correction-history">補正履歴</button>
        </div>
        
        <!-- メッセージエリア -->
        <div id="messageContainer"></div>
        
        <!-- ============================================ -->
        <!-- 失敗一覧タブ -->
        <!-- ============================================ -->
        <div id="failures-list" class="tab-content active">
            <!-- サマリー -->
            <div class="summary">
                <div class="summary-card warning">
                    <h3>未解決</h3>
                    <div class="value" id="statsPending">-</div>
                </div>
                <div class="summary-card success">
                    <h3>解決済み</h3>
                    <div class="value" id="statsResolved">-</div>
                </div>
                <div class="summary-card">
                    <h3>無視</h3>
                    <div class="value" id="statsIgnored">-</div>
                </div>
                <div class="summary-card">
                    <h3>合計</h3>
                    <div class="value" id="statsTotal">-</div>
                </div>
            </div>
            
            <!-- フィルタ -->
            <div class="section">
                <div class="controls">
                    <div class="control-group">
                        <label>開始日</label>
                        <input type="date" id="filterStartDate">
                    </div>
                    <div class="control-group">
                        <label>終了日</label>
                        <input type="date" id="filterEndDate">
                    </div>
                    <div class="control-group">
                        <label>店舗（複数選択可・Ctrl+クリック）</label>
                        <select id="filterHole" multiple size="4" style="min-width: 200px;">
                        </select>
                        <button type="button" class="btn-secondary" onclick="clearHoleFilter()" style="margin-top: 4px; padding: 4px 8px; font-size: 12px;">選択クリア</button>
                    </div>
                    <div class="control-group">
                        <label>ステータス</label>
                        <select id="filterStatus">
                            <option value="">全て</option>
                            <option value="pending" selected>未解決</option>
                            <option value="resolved">解決済み</option>
                            <option value="ignored">無視</option>
                        </select>
                    </div>
                    <button id="searchFailuresBtn">検索</button>
                    <button id="refreshFailuresBtn" class="btn-secondary">更新</button>
                </div>
                
                <!-- 一括操作 -->
                <div id="failuresBulkActions" class="bulk-actions hidden">
                    <span class="selected-count"><span id="failuresSelectedCount">0</span>件選択中</span>
                    <button id="ignoreSelectedFailuresBtn" class="btn-secondary">選択を無視</button>
                    <button id="deleteSelectedFailuresBtn" class="btn-danger">選択を削除</button>
                </div>
            </div>
            
            <!-- 失敗一覧テーブル -->
            <div class="table-container">
                <table id="failuresTable">
                    <thead>
                        <tr>
                            <th class="checkbox-col"><input type="checkbox" id="failuresSelectAll" title="全選択"></th>
                            <th class="sortable" data-sort="date">日付</th>
                            <th class="sortable" data-sort="hole">店舗</th>
                            <th class="sortable" data-sort="machine">機種</th>
                            <th class="sortable" data-sort="error_type">エラー種別</th>
                            <th class="sortable" data-sort="status">ステータス</th>
                            <th class="sortable" data-sort="failed_at">失敗日時</th>
                            <th>操作</th>
                        </tr>
                    </thead>
                    <tbody id="failuresTableBody">
                        <tr><td colspan="8" style="text-align: center;">読み込み中...</td></tr>
                    </tbody>
                </table>
            </div>
        </div>
        
        <!-- ============================================ -->
        <!-- 補正入力タブ -->
        <!-- ============================================ -->
        <div id="correction-input" class="tab-content">
            <!-- 選択された失敗レコード -->
            <div id="selectedFailure" class="selected-failure hidden">
                <h3>選択中の失敗レコード</h3>
                <div class="info">
                    <div><span>日付:</span> <strong id="selectedDate">-</strong></div>
                    <div><span>店舗:</span> <strong id="selectedHole">-</strong></div>
                    <div><span>機種:</span> <strong id="selectedMachine">-</strong></div>
                    <div><span>ステータス:</span> <strong id="selectedStatus">-</strong></div>
                </div>
                <div class="selected-actions" id="selectedActions">
                    <button id="openNewTabBtn" class="btn-secondary">新しいタブで開く</button>
                    <button id="copyUrlBtn" class="btn-secondary">URLをコピー</button>
                    <span style="flex: 1;"></span>
                    <button id="markIgnoredBtn" class="btn-secondary">無視する</button>
                    <button id="deleteFailureBtn" class="btn-danger">削除</button>
                </div>
            </div>
            
            <!-- 補正入力レイアウト（2カラム） -->
            <div class="correction-layout">
                <!-- 左: データ入力 -->
                <div class="section">
                    <h2>データ入力</h2>
                    
                    <!-- 機種名入力 -->
                    <div class="controls">
                        <div class="control-group" style="flex: 1;">
                            <label>機種名 *</label>
                            <input type="text" id="machineName" placeholder="例: バジリスク絆2" style="width: 100%;">
                        </div>
                    </div>
                    
                    <!-- クリップボード貼り付けエリア -->
                    <div class="control-group" style="margin-bottom: 16px;">
                        <label>スロレポの一覧テーブルをコピーして貼り付け（自動パース）</label>
                        <textarea id="pasteArea" style="min-height: 200px;" placeholder="台番&#09;差枚&#09;G数&#09;BB&#09;RB&#09;合成
1223&#09;-4,986&#09;6,566&#09;23&#09;0&#09;1/285
1225&#09;-3,877&#09;6,450&#09;37&#09;0&#09;1/174
..."></textarea>
                    </div>
                    
                    <div class="controls">
                        <button id="parseBtn">パース</button>
                        <button id="clearBtn" class="btn-secondary">クリア</button>
                    </div>
                </div>
                
                <!-- 右: プレビュー -->
                <div class="section">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                        <h2 style="margin-bottom: 0;">プレビュー (<span id="previewCount">0</span>件)</h2>
                    </div>
                    
                    <!-- メモとアクションボタン（上部固定） -->
                    <div class="control-group" style="margin-bottom: 12px;">
                        <label>メモ（任意）</label>
                        <input type="text" id="correctionNotes" placeholder="補正理由など" style="width: 100%;">
                    </div>
                    
                    <div class="action-buttons" style="margin-top: 0; margin-bottom: 16px; justify-content: flex-start;">
                        <button id="registerNextBtn" class="btn-success" disabled>登録して次へ</button>
                        <span style="flex: 1;"></span>
                        <button id="registerBtn" class="btn-secondary" disabled>登録のみ</button>
                        <button id="skipNextBtn" class="btn-secondary" disabled>スキップ</button>
                    </div>
                    
                    <!-- プレビューテーブル -->
                    <div class="preview-table" style="max-height: 400px;">
                        <table>
                            <thead>
                                <tr>
                                    <th>台番</th>
                                    <th>差枚</th>
                                    <th>G数</th>
                                    <th>BB</th>
                                    <th>RB</th>
                                    <th>合成</th>
                                </tr>
                            </thead>
                            <tbody id="previewTableBody">
                                <tr><td colspan="6" style="text-align: center; color: var(--text-secondary);">データを貼り付けると自動でパースされます</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- ============================================ -->
        <!-- 補正履歴タブ -->
        <!-- ============================================ -->
        <div id="correction-history" class="tab-content">
            <!-- フィルタ -->
            <div class="section">
                <div class="controls">
                    <div class="control-group">
                        <label>開始日</label>
                        <input type="date" id="historyStartDate">
                    </div>
                    <div class="control-group">
                        <label>終了日</label>
                        <input type="date" id="historyEndDate">
                    </div>
                    <div class="control-group">
                        <label>店舗</label>
                        <select id="historyHole">
                            <option value="">全て</option>
                        </select>
                    </div>
                    <button id="searchHistoryBtn">検索</button>
                </div>
                
                <!-- 一括操作 -->
                <div id="historyBulkActions" class="bulk-actions hidden">
                    <span class="selected-count"><span id="historySelectedCount">0</span>件選択中</span>
                    <button id="deleteSelectedHistoryBtn" class="btn-danger">選択を削除</button>
                </div>
            </div>
            
            <!-- 補正履歴テーブル -->
            <div class="table-container">
                <table id="historyTable">
                    <thead>
                        <tr>
                            <th class="checkbox-col"><input type="checkbox" id="historySelectAll" title="全選択"></th>
                            <th class="sortable" data-sort="date">日付</th>
                            <th class="sortable" data-sort="hole">店舗</th>
                            <th class="sortable" data-sort="machine">機種</th>
                            <th class="sortable" data-sort="count">件数</th>
                            <th class="sortable" data-sort="last_corrected">補正日時</th>
                            <th>操作</th>
                        </tr>
                    </thead>
                    <tbody id="historyTableBody">
                        <tr><td colspan="7" style="text-align: center;">読み込み中...</td></tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>
    
    <script>
        // ============================================
        // 状態管理
        // ============================================
        let failures = [];
        let history = [];
        let previewData = [];
        let selectedFailure = null;
        let slorepoUrl = null;
        
        // ソート状態
        let failuresSort = { key: 'failed_at', order: 'desc' };
        let historySort = { key: 'last_corrected', order: 'desc' };
        
        // 選択状態
        let selectedFailureIds = new Set();
        let selectedHistoryItems = new Set(); // `${date}|${hole}|${machine}` 形式
        
        // 自動パース用debounceタイマー
        let parseDebounceTimer = null;
        
        // ============================================
        // 初期化
        // ============================================
        document.addEventListener('DOMContentLoaded', () => {
            initDates();
            initTabs();
            initEventListeners();
            initSortHandlers();
            initCheckboxHandlers();
            loadStats();
            loadFailures();
            loadHoles();
        });
        
        function initDates() {
            const days = CONFIG.defaultDateRanges.failures;
            const today = getJSTDate(0);
            const startDate = getJSTDate(-days);
            
            document.getElementById('filterStartDate').value = startDate;
            document.getElementById('filterEndDate').value = today;
            document.getElementById('historyStartDate').value = startDate;
            document.getElementById('historyEndDate').value = today;
        }
        
        function initTabs() {
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    
                    tab.classList.add('active');
                    const targetId = tab.dataset.tab;
                    document.getElementById(targetId).classList.add('active');
                    
                    if (targetId === 'correction-history') {
                        loadHistory();
                    }
                });
            });
        }
        
        // 店舗フィルターの選択をクリア
        function clearHoleFilter() {
            const select = document.getElementById('filterHole');
            Array.from(select.options).forEach(opt => opt.selected = false);
        }
        
        function initEventListeners() {
            // 失敗一覧
            document.getElementById('searchFailuresBtn').addEventListener('click', loadFailures);
            document.getElementById('refreshFailuresBtn').addEventListener('click', () => {
                loadStats();
                loadFailures();
            });
            
            // 補正入力
            document.getElementById('parseBtn').addEventListener('click', parseData);
            document.getElementById('clearBtn').addEventListener('click', clearForm);
            document.getElementById('registerBtn').addEventListener('click', () => registerCorrection(false));
            document.getElementById('registerNextBtn').addEventListener('click', () => registerCorrection(true));
            document.getElementById('skipNextBtn').addEventListener('click', skipToNext);
            document.getElementById('openNewTabBtn').addEventListener('click', openSlorepoInNewTab);
            document.getElementById('copyUrlBtn').addEventListener('click', copySlorepoUrl);
            
            // 自動パース（1秒debounce）
            document.getElementById('pasteArea').addEventListener('input', () => {
                clearTimeout(parseDebounceTimer);
                parseDebounceTimer = setTimeout(() => {
                    parseDataAuto();
                }, 1000);
            });
            
            // 補正履歴
            document.getElementById('searchHistoryBtn').addEventListener('click', loadHistory);
            
            // 一括操作
            document.getElementById('ignoreSelectedFailuresBtn').addEventListener('click', ignoreSelectedFailures);
            document.getElementById('deleteSelectedFailuresBtn').addEventListener('click', deleteSelectedFailures);
            document.getElementById('deleteSelectedHistoryBtn').addEventListener('click', deleteSelectedHistory);
            
            // 選択中レコードのアクション
            document.getElementById('markIgnoredBtn').addEventListener('click', () => markSelectedAs('ignored'));
            document.getElementById('deleteFailureBtn').addEventListener('click', deleteSelectedFailure);
        }
        
        // ソートハンドラー初期化
        function initSortHandlers() {
            // 失敗一覧のソート
            document.querySelectorAll('#failuresTable th.sortable').forEach(th => {
                th.addEventListener('click', () => {
                    const key = th.dataset.sort;
                    if (failuresSort.key === key) {
                        failuresSort.order = failuresSort.order === 'asc' ? 'desc' : 'asc';
                    } else {
                        failuresSort.key = key;
                        failuresSort.order = 'asc';
                    }
                    updateSortIndicators('failuresTable', failuresSort);
                    renderFailuresTable();
                });
            });
            
            // 補正履歴のソート
            document.querySelectorAll('#historyTable th.sortable').forEach(th => {
                th.addEventListener('click', () => {
                    const key = th.dataset.sort;
                    if (historySort.key === key) {
                        historySort.order = historySort.order === 'asc' ? 'desc' : 'asc';
                    } else {
                        historySort.key = key;
                        historySort.order = 'asc';
                    }
                    updateSortIndicators('historyTable', historySort);
                    renderHistoryTable();
                });
            });
        }
        
        // ソートインジケーター更新
        function updateSortIndicators(tableId, sortState) {
            const table = document.getElementById(tableId);
            table.querySelectorAll('th.sortable').forEach(th => {
                th.classList.remove('asc', 'desc');
                if (th.dataset.sort === sortState.key) {
                    th.classList.add(sortState.order);
                }
            });
        }
        
        // チェックボックスハンドラー初期化
        function initCheckboxHandlers() {
            // 失敗一覧の全選択
            document.getElementById('failuresSelectAll').addEventListener('change', (e) => {
                const checked = e.target.checked;
                selectedFailureIds.clear();
                if (checked) {
                    failures.forEach(f => selectedFailureIds.add(f.id));
                }
                renderFailuresTable();
                updateBulkActionsVisibility('failures');
            });
            
            // 補正履歴の全選択
            document.getElementById('historySelectAll').addEventListener('change', (e) => {
                const checked = e.target.checked;
                selectedHistoryItems.clear();
                if (checked) {
                    history.forEach(h => selectedHistoryItems.add(`${h.date}|${h.hole}|${h.machine}`));
                }
                renderHistoryTable();
                updateBulkActionsVisibility('history');
            });
        }
        
        // 一括操作バーの表示/非表示
        function updateBulkActionsVisibility(type) {
            if (type === 'failures') {
                const bulkActions = document.getElementById('failuresBulkActions');
                const countEl = document.getElementById('failuresSelectedCount');
                countEl.textContent = selectedFailureIds.size;
                bulkActions.classList.toggle('hidden', selectedFailureIds.size === 0);
            } else {
                const bulkActions = document.getElementById('historyBulkActions');
                const countEl = document.getElementById('historySelectedCount');
                countEl.textContent = selectedHistoryItems.size;
                bulkActions.classList.toggle('hidden', selectedHistoryItems.size === 0);
            }
        }
        
        // ============================================
        // API呼び出し
        // ============================================
        async function loadStats() {
            try {
                const response = await fetch('/api/failures/stats');
                const result = await response.json();
                
                if (result.success) {
                    document.getElementById('statsPending').textContent = result.stats.pending;
                    document.getElementById('statsResolved').textContent = result.stats.resolved;
                    document.getElementById('statsIgnored').textContent = result.stats.ignored;
                    document.getElementById('statsTotal').textContent = result.stats.total;
                }
            } catch (error) {
                console.error('統計取得エラー:', error);
            }
        }
        
        async function loadFailures() {
            const startDate = document.getElementById('filterStartDate').value;
            const endDate = document.getElementById('filterEndDate').value;
            const status = document.getElementById('filterStatus').value;
            
            // 複数選択された店舗を取得
            const filterHoleSelect = document.getElementById('filterHole');
            const selectedHoles = Array.from(filterHoleSelect.selectedOptions).map(opt => opt.value);
            
            const params = new URLSearchParams();
            if (startDate) params.append('startDate', startDate);
            if (endDate) params.append('endDate', endDate);
            if (selectedHoles.length > 0) {
                params.append('holes', selectedHoles.join(','));
            }
            if (status) params.append('status', status);
            
            try {
                const response = await fetch(`/api/failures?${params}`);
                const result = await response.json();
                
                if (result.success) {
                    failures = result.data;
                    selectedFailureIds.clear();
                    document.getElementById('failuresSelectAll').checked = false;
                    updateBulkActionsVisibility('failures');
                    renderFailuresTable();
                }
            } catch (error) {
                console.error('失敗一覧取得エラー:', error);
                showMessage('失敗一覧の取得に失敗しました', 'error');
            }
        }
        
        async function loadHoles() {
            try {
                const response = await fetch('/api/data-status?start=2026-01-01&end=2026-01-01');
                const result = await response.json();
                
                if (result.holes) {
                    // 失敗一覧（複数選択）
                    const filterSelect = document.getElementById('filterHole');
                    result.holes.forEach(hole => {
                        const option = document.createElement('option');
                        option.value = hole.name;
                        option.textContent = hole.name;
                        filterSelect.appendChild(option);
                    });
                    
                    // 補正履歴（単一選択、従来通り）
                    const historySelect = document.getElementById('historyHole');
                    result.holes.forEach(hole => {
                        const option = document.createElement('option');
                        option.value = hole.name;
                        option.textContent = hole.name;
                        historySelect.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('店舗一覧取得エラー:', error);
            }
        }
        
        async function loadHistory() {
            const startDate = document.getElementById('historyStartDate').value;
            const endDate = document.getElementById('historyEndDate').value;
            const hole = document.getElementById('historyHole').value;
            
            const params = new URLSearchParams();
            if (startDate) params.append('startDate', startDate);
            if (endDate) params.append('endDate', endDate);
            if (hole) params.append('hole', hole);
            
            try {
                const response = await fetch(`/api/corrections/summary?${params}`);
                const result = await response.json();
                
                if (result.success) {
                    history = result.data;
                    selectedHistoryItems.clear();
                    document.getElementById('historySelectAll').checked = false;
                    updateBulkActionsVisibility('history');
                    renderHistoryTable();
                }
            } catch (error) {
                console.error('補正履歴取得エラー:', error);
            }
        }
        
        // ============================================
        // テーブル描画
        // ============================================
        // ソート関数
        function sortData(data, sortState) {
            return [...data].sort((a, b) => {
                let aVal = a[sortState.key];
                let bVal = b[sortState.key];
                
                // nullチェック
                if (aVal == null) aVal = '';
                if (bVal == null) bVal = '';
                
                // 数値比較
                if (typeof aVal === 'number' && typeof bVal === 'number') {
                    return sortState.order === 'asc' ? aVal - bVal : bVal - aVal;
                }
                
                // 文字列比較
                const comparison = String(aVal).localeCompare(String(bVal), 'ja');
                return sortState.order === 'asc' ? comparison : -comparison;
            });
        }
        
        function renderFailuresTable() {
            const tbody = document.getElementById('failuresTableBody');
            
            if (failures.length === 0) {
                tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; color: var(--text-secondary);">該当するデータがありません</td></tr>';
                return;
            }
            
            const sorted = sortData(failures, failuresSort);
            
            tbody.innerHTML = sorted.map(f => `
                <tr>
                    <td class="checkbox-col">
                        <input type="checkbox" 
                               ${selectedFailureIds.has(f.id) ? 'checked' : ''} 
                               onchange="toggleFailureSelection('${f.id}', this.checked)">
                    </td>
                    <td>${f.date}</td>
                    <td>${f.hole}</td>
                    <td>${f.machine || '-'}</td>
                    <td><span class="badge badge-${f.error_type}">${f.error_type}</span></td>
                    <td><span class="badge badge-${f.status}">${getStatusLabel(f.status)}</span></td>
                    <td>${formatDateTime(f.failed_at)}</td>
                    <td>
                        <button class="btn-secondary" onclick="selectFailure('${f.id}')" style="padding: 4px 8px; font-size: 12px;">補正</button>
                        ${f.status === 'pending' ? `
                            <button class="btn-secondary" onclick="ignoreFailure('${f.id}')" style="padding: 4px 8px; font-size: 12px;">無視</button>
                        ` : ''}
                    </td>
                </tr>
            `).join('');
            
            // 全選択チェックボックスの状態更新
            const allSelected = failures.length > 0 && failures.every(f => selectedFailureIds.has(f.id));
            document.getElementById('failuresSelectAll').checked = allSelected;
        }
        
        function renderHistoryTable() {
            const tbody = document.getElementById('historyTableBody');
            
            if (history.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" style="text-align: center; color: var(--text-secondary);">該当するデータがありません</td></tr>';
                return;
            }
            
            const sorted = sortData(history, historySort);
            
            tbody.innerHTML = sorted.map(h => {
                const key = `${h.date}|${h.hole}|${h.machine}`;
                return `
                <tr>
                    <td class="checkbox-col">
                        <input type="checkbox" 
                               ${selectedHistoryItems.has(key) ? 'checked' : ''} 
                               onchange="toggleHistorySelection('${h.date}', '${h.hole}', '${h.machine}', this.checked)">
                    </td>
                    <td>${h.date}</td>
                    <td>${h.hole}</td>
                    <td>${h.machine}</td>
                    <td>${h.count}件</td>
                    <td>${formatDateTime(h.last_corrected)}</td>
                    <td>
                        <button class="btn-danger" onclick="deleteCorrections('${h.date}', '${h.hole}', '${h.machine}')" style="padding: 4px 8px; font-size: 12px;">削除</button>
                    </td>
                </tr>
            `}).join('');
            
            // 全選択チェックボックスの状態更新
            const allSelected = history.length > 0 && history.every(h => selectedHistoryItems.has(`${h.date}|${h.hole}|${h.machine}`));
            document.getElementById('historySelectAll').checked = allSelected;
        }
        
        // 選択トグル関数
        function toggleFailureSelection(id, checked) {
            if (checked) {
                selectedFailureIds.add(id);
            } else {
                selectedFailureIds.delete(id);
            }
            updateBulkActionsVisibility('failures');
            // 全選択チェックボックスの状態更新
            const allSelected = failures.length > 0 && failures.every(f => selectedFailureIds.has(f.id));
            document.getElementById('failuresSelectAll').checked = allSelected;
        }
        
        function toggleHistorySelection(date, hole, machine, checked) {
            const key = `${date}|${hole}|${machine}`;
            if (checked) {
                selectedHistoryItems.add(key);
            } else {
                selectedHistoryItems.delete(key);
            }
            updateBulkActionsVisibility('history');
            // 全選択チェックボックスの状態更新
            const allSelected = history.length > 0 && history.every(h => selectedHistoryItems.has(`${h.date}|${h.hole}|${h.machine}`));
            document.getElementById('historySelectAll').checked = allSelected;
        }
        
        function renderPreviewTable() {
            const tbody = document.getElementById('previewTableBody');
            document.getElementById('previewCount').textContent = previewData.length;
            
            if (previewData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: var(--text-secondary);">データを貼り付けてパースしてください</td></tr>';
                updateActionButtonsState();
                return;
            }
            
            tbody.innerHTML = previewData.map((row, i) => `
                <tr>
                    <td>${row.machineNumber}</td>
                    <td style="color: ${row.diff >= 0 ? 'var(--accent-green)' : 'var(--accent-red)'}">${row.diff.toLocaleString()}</td>
                    <td>${row.game.toLocaleString()}</td>
                    <td>${row.big}</td>
                    <td>${row.reg}</td>
                    <td>${row.combinedRate}</td>
                </tr>
            `).join('');
            
            updateActionButtonsState();
        }
        
        // ============================================
        // アクション
        // ============================================
        function selectFailure(id) {
            selectedFailure = failures.find(f => f.id === id);
            
            if (!selectedFailure) return;
            
            // 補正入力タブに切り替え
            document.querySelector('[data-tab="correction-input"]').click();
            
            // 選択情報を表示
            document.getElementById('selectedFailure').classList.remove('hidden');
            document.getElementById('selectedDate').textContent = selectedFailure.date;
            document.getElementById('selectedHole').textContent = selectedFailure.hole;
            document.getElementById('selectedMachine').textContent = selectedFailure.machine || '不明';
            document.getElementById('selectedStatus').textContent = getStatusLabel(selectedFailure.status);
            
            // ステータスに応じてボタンを表示/非表示
            const isPending = selectedFailure.status === 'pending';
            document.getElementById('markIgnoredBtn').style.display = isPending ? '' : 'none';
            
            // 機種名を自動入力
            if (selectedFailure.machine) {
                document.getElementById('machineName').value = selectedFailure.machine;
            }
            
            // スロレポURLを設定
            slorepoUrl = selectedFailure.machine_url;
            
            // URLボタンの表示/非表示
            document.getElementById('openNewTabBtn').style.display = slorepoUrl ? '' : 'none';
            document.getElementById('copyUrlBtn').style.display = slorepoUrl ? '' : 'none';
            
            // アクションボタンの状態更新
            updateActionButtonsState();
        }
        
        // 選択中レコードのステータス変更
        async function markSelectedAs(status) {
            if (!selectedFailure) return;
            
            const statusLabel = status === 'resolved' ? '解決済み' : '無視';
            if (!confirm(`このレコードを「${statusLabel}」にしますか？`)) return;
            
            showLoading('ステータスを更新中...');
            try {
                const response = await fetch(`/api/failures/${selectedFailure.id}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        status, 
                        resolvedMethod: status === 'resolved' ? 'manual' : undefined 
                    }),
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showMessage(`ステータスを「${statusLabel}」に更新しました`, 'success');
                    // 選択中レコードを更新
                    selectedFailure.status = status;
                    document.getElementById('selectedStatus').textContent = getStatusLabel(status);
                    document.getElementById('markIgnoredBtn').style.display = 'none';
                    // 一覧を更新
                    loadStats();
                    loadFailures();
                } else {
                    showMessage(result.error || '更新に失敗しました', 'error');
                }
            } catch (error) {
                console.error('ステータス更新エラー:', error);
                showMessage('更新中にエラーが発生しました', 'error');
            } finally {
                hideLoading();
            }
        }
        
        // 選択中レコードの削除
        async function deleteSelectedFailure() {
            if (!selectedFailure) return;
            
            if (!confirm('この失敗レコードを削除しますか？')) return;
            
            showLoading('削除中...');
            try {
                const response = await fetch(`/api/failures/${selectedFailure.id}`, {
                    method: 'DELETE',
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showMessage('失敗レコードを削除しました', 'success');
                    // 選択をクリア
                    selectedFailure = null;
                    document.getElementById('selectedFailure').classList.add('hidden');
                    // 一覧を更新
                    loadStats();
                    loadFailures();
                } else {
                    showMessage(result.error || '削除に失敗しました', 'error');
                }
            } catch (error) {
                console.error('削除エラー:', error);
                showMessage('削除中にエラーが発生しました', 'error');
            } finally {
                hideLoading();
            }
        }
        
        function openSlorepoInNewTab() {
            if (slorepoUrl) {
                window.open(slorepoUrl, '_blank');
            } else {
                showMessage('URLが設定されていません', 'error');
            }
        }
        
        async function copySlorepoUrl() {
            if (!slorepoUrl) {
                showMessage('URLが設定されていません', 'error');
                return;
            }
            
            try {
                await navigator.clipboard.writeText(slorepoUrl);
                showMessage('URLをクリップボードにコピーしました', 'success');
            } catch (error) {
                console.error('コピーエラー:', error);
                showMessage('コピーに失敗しました', 'error');
            }
        }
        
        // 手動パース（エラーメッセージあり）
        function parseData() {
            const text = document.getElementById('pasteArea').value;
            
            if (!text.trim()) {
                showMessage('データを貼り付けてください', 'error');
                return;
            }
            
            const lines = text.trim().split('\n');
            previewData = lines
                .map(line => line.split('\t'))
                .filter(cells => {
                    const firstCell = cells[0]?.trim();
                    return firstCell && firstCell !== '台番' && firstCell !== '平均';
                })
                .map(cells => ({
                    machineNumber: parseInt(cells[0]?.trim() || '0', 10),
                    diff: parseInt((cells[1] || '0').replace(/[,+]/g, ''), 10),
                    game: parseInt((cells[2] || '0').replace(/,/g, ''), 10),
                    big: parseInt(cells[3]?.trim() || '0', 10),
                    reg: parseInt(cells[4]?.trim() || '0', 10),
                    combinedRate: cells[5]?.trim() || '',
                }))
                .filter(row => !isNaN(row.machineNumber) && row.machineNumber > 0);
            
            if (previewData.length === 0) {
                showMessage('有効なデータが見つかりませんでした', 'error');
                return;
            }
            
            renderPreviewTable();
            showMessage(`${previewData.length}件のデータをパースしました`, 'success');
        }
        
        // 自動パース（エラーメッセージなし、静かに動作）
        function parseDataAuto() {
            const text = document.getElementById('pasteArea').value;
            
            if (!text.trim()) {
                previewData = [];
                renderPreviewTable();
                return;
            }
            
            const lines = text.trim().split('\n');
            previewData = lines
                .map(line => line.split('\t'))
                .filter(cells => {
                    const firstCell = cells[0]?.trim();
                    return firstCell && firstCell !== '台番' && firstCell !== '平均';
                })
                .map(cells => ({
                    machineNumber: parseInt(cells[0]?.trim() || '0', 10),
                    diff: parseInt((cells[1] || '0').replace(/[,+]/g, ''), 10),
                    game: parseInt((cells[2] || '0').replace(/,/g, ''), 10),
                    big: parseInt(cells[3]?.trim() || '0', 10),
                    reg: parseInt(cells[4]?.trim() || '0', 10),
                    combinedRate: cells[5]?.trim() || '',
                }))
                .filter(row => !isNaN(row.machineNumber) && row.machineNumber > 0);
            
            renderPreviewTable();
        }
        
        function clearForm() {
            document.getElementById('pasteArea').value = '';
            document.getElementById('machineName').value = '';
            document.getElementById('correctionNotes').value = '';
            previewData = [];
            renderPreviewTable();
        }
        
        // 選択をクリア
        function clearSelection() {
            selectedFailure = null;
            document.getElementById('selectedFailure').classList.add('hidden');
            updateActionButtonsState();
        }
        
        // 次の未解決レコードへ移動
        function goToNextPendingFailure() {
            // 現在のレコードの次にある未解決レコードを探す
            const currentIndex = failures.findIndex(f => f.id === selectedFailure?.id);
            const pendingAfter = failures.slice(currentIndex + 1).find(f => f.status === 'pending');
            const pendingBefore = failures.find(f => f.status === 'pending');
            
            const next = pendingAfter || pendingBefore;
            
            if (next && next.id !== selectedFailure?.id) {
                clearForm();
                selectFailure(next.id);
            } else {
                showMessage('未解決のレコードはありません', 'info');
                clearForm();
                clearSelection();
            }
        }
        
        // アクションボタンの状態更新
        function updateActionButtonsState() {
            const hasSelection = selectedFailure !== null;
            const hasData = previewData.length > 0;
            const isPending = selectedFailure?.status === 'pending';
            
            // 登録系ボタンはデータがある場合のみ有効
            document.getElementById('registerBtn').disabled = !hasSelection || !hasData;
            document.getElementById('registerNextBtn').disabled = !hasSelection || !hasData;
            
            // スキップは選択があれば有効
            document.getElementById('skipNextBtn').disabled = !hasSelection;
        }
        
        // 補正データ登録（goNext: true で登録後に次へ移動）
        async function registerCorrection(goNext = false) {
            if (!selectedFailure) {
                showMessage('失敗レコードを選択してください', 'error');
                return;
            }
            
            const machineName = document.getElementById('machineName').value.trim();
            if (!machineName) {
                showMessage('機種名を入力してください', 'error');
                return;
            }
            
            if (previewData.length === 0) {
                showMessage('データをパースしてください', 'error');
                return;
            }
            
            const notes = document.getElementById('correctionNotes').value.trim();
            
            showLoading('補正データを登録中...');
            try {
                const response = await fetch('/api/corrections', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        date: selectedFailure.date,
                        hole: selectedFailure.hole,
                        machine: machineName,
                        failureId: selectedFailure.id,
                        notes: notes || null,
                        data: previewData,
                    }),
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showMessage(`${result.count}件の補正データを登録しました`, 'success');
                    
                    // 選択中レコードのステータスを更新
                    selectedFailure.status = 'resolved';
                    document.getElementById('selectedStatus').textContent = getStatusLabel('resolved');
                    
                    // 一覧を更新
                    loadStats();
                    await loadFailures();
                    
                    if (goNext) {
                        // 次の未解決へ移動
                        goToNextPendingFailure();
                    } else {
                        // 登録のみ：フォームクリアして選択維持
                        clearForm();
                        updateActionButtonsState();
                    }
                } else {
                    showMessage(result.error || '登録に失敗しました', 'error');
                }
            } catch (error) {
                console.error('登録エラー:', error);
                showMessage('登録中にエラーが発生しました', 'error');
            } finally {
                hideLoading();
            }
        }
        
        // スキップして次へ（何もせず次の未解決へ）
        function skipToNext() {
            goToNextPendingFailure();
        }
        
        async function ignoreFailure(id) {
            if (!confirm('この失敗レコードを無視しますか？')) return;
            
            showLoading('ステータスを更新中...');
            try {
                const response = await fetch(`/api/failures/${id}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ status: 'ignored' }),
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showMessage('ステータスを更新しました', 'success');
                    loadStats();
                    loadFailures();
                } else {
                    showMessage(result.error || '更新に失敗しました', 'error');
                }
            } catch (error) {
                console.error('更新エラー:', error);
                showMessage('更新中にエラーが発生しました', 'error');
            } finally {
                hideLoading();
            }
        }
        
        async function deleteCorrections(date, hole, machine) {
            if (!confirm(`${date} / ${hole} / ${machine} の補正データを削除しますか？`)) return;
            
            showLoading('補正データを削除中...');
            try {
                const response = await fetch('/api/corrections/bulk', {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ date, hole, machine }),
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showMessage(`${result.count}件の補正データを削除しました`, 'success');
                    loadHistory();
                } else {
                    showMessage(result.error || '削除に失敗しました', 'error');
                }
            } catch (error) {
                console.error('削除エラー:', error);
                showMessage('削除中にエラーが発生しました', 'error');
            } finally {
                hideLoading();
            }
        }
        
        // 失敗レコード一括無視
        async function ignoreSelectedFailures() {
            if (selectedFailureIds.size === 0) return;
            
            if (!confirm(`${selectedFailureIds.size}件の失敗レコードを無視しますか？`)) return;
            
            showLoading(`${selectedFailureIds.size}件を無視中...`);
            let successCount = 0;
            let errorCount = 0;
            
            try {
                for (const id of selectedFailureIds) {
                    try {
                        const response = await fetch(`/api/failures/${id}`, {
                            method: 'PATCH',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ status: 'ignored' }),
                        });
                        
                        const result = await response.json();
                        if (result.success) {
                            successCount++;
                        } else {
                            errorCount++;
                        }
                    } catch (error) {
                        errorCount++;
                    }
                }
                
                if (successCount > 0) {
                    showMessage(`${successCount}件の失敗レコードを無視しました${errorCount > 0 ? `（${errorCount}件失敗）` : ''}`, errorCount > 0 ? 'warning' : 'success');
                } else {
                    showMessage('更新に失敗しました', 'error');
                }
                
                selectedFailureIds.clear();
                updateBulkActionsVisibility('failures');
                loadStats();
                loadFailures();
            } finally {
                hideLoading();
            }
        }
        
        // 失敗レコード一括削除
        async function deleteSelectedFailures() {
            if (selectedFailureIds.size === 0) return;
            
            if (!confirm(`${selectedFailureIds.size}件の失敗レコードを削除しますか？`)) return;
            
            showLoading(`${selectedFailureIds.size}件を削除中...`);
            try {
                const response = await fetch('/api/failures/bulk', {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ids: Array.from(selectedFailureIds) }),
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showMessage(`${result.count}件の失敗レコードを削除しました`, 'success');
                    selectedFailureIds.clear();
                    updateBulkActionsVisibility('failures');
                    loadStats();
                    loadFailures();
                } else {
                    showMessage(result.error || '削除に失敗しました', 'error');
                }
            } catch (error) {
                console.error('一括削除エラー:', error);
                showMessage('削除中にエラーが発生しました', 'error');
            } finally {
                hideLoading();
            }
        }
        
        // 補正履歴一括削除
        async function deleteSelectedHistory() {
            if (selectedHistoryItems.size === 0) return;
            
            if (!confirm(`${selectedHistoryItems.size}件の補正データを削除しますか？`)) return;
            
            showLoading(`${selectedHistoryItems.size}件を削除中...`);
            let successCount = 0;
            let errorCount = 0;
            
            try {
                for (const key of selectedHistoryItems) {
                    const [date, hole, machine] = key.split('|');
                    try {
                        const response = await fetch('/api/corrections/bulk', {
                            method: 'DELETE',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ date, hole, machine }),
                        });
                        
                        const result = await response.json();
                        if (result.success) {
                            successCount++;
                        } else {
                            errorCount++;
                        }
                    } catch (error) {
                        errorCount++;
                    }
                }
                
                if (successCount > 0) {
                    showMessage(`${successCount}件の補正データを削除しました${errorCount > 0 ? `（${errorCount}件失敗）` : ''}`, errorCount > 0 ? 'warning' : 'success');
                } else {
                    showMessage('削除に失敗しました', 'error');
                }
                
                selectedHistoryItems.clear();
                updateBulkActionsVisibility('history');
                loadHistory();
            } finally {
                hideLoading();
            }
        }
        
        // ============================================
        // ユーティリティ
        // ============================================
        function formatDate(date) {
            return date.toISOString().split('T')[0];
        }
        
        function formatDateTime(isoString) {
            if (!isoString) return '-';
            const date = new Date(isoString);
            return `${date.getMonth() + 1}/${date.getDate()} ${date.getHours()}:${String(date.getMinutes()).padStart(2, '0')}`;
        }
        
        function getStatusLabel(status) {
            const labels = {
                pending: '未解決',
                resolved: '解決済み',
                ignored: '無視',
            };
            return labels[status] || status;
        }
        
        function showMessage(message, type) {
            const container = document.getElementById('messageContainer');
            container.innerHTML = `<div class="message ${type}">${message}</div>`;
            setTimeout(() => { container.innerHTML = ''; }, 5000);
        }
        
        // ローディングオーバーレイ表示
        function showLoading(text = '処理中...') {
            document.getElementById('loadingText').textContent = text;
            document.getElementById('loadingOverlay').classList.remove('hidden');
        }
        
        // ローディングオーバーレイ非表示
        function hideLoading() {
            document.getElementById('loadingOverlay').classList.add('hidden');
        }
    </script>
</body>
</html>
